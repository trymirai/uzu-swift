// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(uzu_plusFFI)
import uzu_plusFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_uzu_plus_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_uzu_plus_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureUzuPlusInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterFloat: FfiConverterPrimitive {
    typealias FfiType = Float
    typealias SwiftType = Float

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Float {
        return try lift(readFloat(&buf))
    }

    public static func write(_ value: Float, into buf: inout [UInt8]) {
        writeFloat(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}




/**
 * Thin FFI wrapper around `ModelStorage`.
 */
public protocol EngineProtocol: AnyObject, Sendable {
    
    func createSession(modelId: String) throws  -> Session
    
    func delete(identifier: String) 
    
    func download(identifier: String) throws 
    
    func getModels()  -> [Model]
    
    func getState(identifier: String)  -> ModelState
    
    func pause(identifier: String) 
    
    /**
     * Register a Rust callback that will receive license status updates.
     */
    func registerLicenseStatusHandler(handler: LicenseStatusHandler) 
    
    /**
     * Register a callback that will receive model state updates.
     */
    func registerModelStateHandler(handler: ModelStateHandler) 
    
    func resume(identifier: String) 
    
    func setState(identifier: String, state: ModelState) 
    
    func stop(identifier: String) 
    
    func stopInternal(identifier: String) 
    
    func updateRegistry() async throws  -> [Model]
    
}
/**
 * Thin FFI wrapper around `ModelStorage`.
 */
open class Engine: EngineProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_uzu_plus_fn_clone_engine(self.pointer, $0) }
    }
public convenience init(apiKey: String) {
    let pointer =
        try! rustCall() {
    uniffi_uzu_plus_fn_constructor_engine_new(
        FfiConverterString.lower(apiKey),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_uzu_plus_fn_free_engine(pointer, $0) }
    }

    

    
open func createSession(modelId: String)throws  -> Session  {
    return try  FfiConverterTypeSession_lift(try rustCallWithError(FfiConverterTypeError_lift) {
    uniffi_uzu_plus_fn_method_engine_createsession(self.uniffiClonePointer(),
        FfiConverterString.lower(modelId),$0
    )
})
}
    
open func delete(identifier: String)  {try! rustCall() {
    uniffi_uzu_plus_fn_method_engine_delete(self.uniffiClonePointer(),
        FfiConverterString.lower(identifier),$0
    )
}
}
    
open func download(identifier: String)throws   {try rustCallWithError(FfiConverterTypeError_lift) {
    uniffi_uzu_plus_fn_method_engine_download(self.uniffiClonePointer(),
        FfiConverterString.lower(identifier),$0
    )
}
}
    
open func getModels() -> [Model]  {
    return try!  FfiConverterSequenceTypeModel.lift(try! rustCall() {
    uniffi_uzu_plus_fn_method_engine_getmodels(self.uniffiClonePointer(),$0
    )
})
}
    
open func getState(identifier: String) -> ModelState  {
    return try!  FfiConverterTypeModelState_lift(try! rustCall() {
    uniffi_uzu_plus_fn_method_engine_getstate(self.uniffiClonePointer(),
        FfiConverterString.lower(identifier),$0
    )
})
}
    
open func pause(identifier: String)  {try! rustCall() {
    uniffi_uzu_plus_fn_method_engine_pause(self.uniffiClonePointer(),
        FfiConverterString.lower(identifier),$0
    )
}
}
    
    /**
     * Register a Rust callback that will receive license status updates.
     */
open func registerLicenseStatusHandler(handler: LicenseStatusHandler)  {try! rustCall() {
    uniffi_uzu_plus_fn_method_engine_registerlicensestatushandler(self.uniffiClonePointer(),
        FfiConverterCallbackInterfaceLicenseStatusHandler_lower(handler),$0
    )
}
}
    
    /**
     * Register a callback that will receive model state updates.
     */
open func registerModelStateHandler(handler: ModelStateHandler)  {try! rustCall() {
    uniffi_uzu_plus_fn_method_engine_registermodelstatehandler(self.uniffiClonePointer(),
        FfiConverterCallbackInterfaceModelStateHandler_lower(handler),$0
    )
}
}
    
open func resume(identifier: String)  {try! rustCall() {
    uniffi_uzu_plus_fn_method_engine_resume(self.uniffiClonePointer(),
        FfiConverterString.lower(identifier),$0
    )
}
}
    
open func setState(identifier: String, state: ModelState)  {try! rustCall() {
    uniffi_uzu_plus_fn_method_engine_set_state(self.uniffiClonePointer(),
        FfiConverterString.lower(identifier),
        FfiConverterTypeModelState_lower(state),$0
    )
}
}
    
open func stop(identifier: String)  {try! rustCall() {
    uniffi_uzu_plus_fn_method_engine_stop(self.uniffiClonePointer(),
        FfiConverterString.lower(identifier),$0
    )
}
}
    
open func stopInternal(identifier: String)  {try! rustCall() {
    uniffi_uzu_plus_fn_method_engine_stop_internal(self.uniffiClonePointer(),
        FfiConverterString.lower(identifier),$0
    )
}
}
    
open func updateRegistry()async throws  -> [Model]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_uzu_plus_fn_method_engine_updateregistry(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_uzu_plus_rust_future_poll_rust_buffer,
            completeFunc: ffi_uzu_plus_rust_future_complete_rust_buffer,
            freeFunc: ffi_uzu_plus_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeModel.lift,
            errorHandler: FfiConverterTypeError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEngine: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Engine

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Engine {
        return Engine(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Engine) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Engine {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Engine, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEngine_lift(_ pointer: UnsafeMutableRawPointer) throws -> Engine {
    return try FfiConverterTypeEngine.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEngine_lower(_ value: Engine) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEngine.lower(value)
}






public protocol SessionProtocol: AnyObject, Sendable {
    
    /**
     * Loads the model configuration. Must be called before `run`.
     */
    func load(config: SessionConfig) throws 
    
    /**
     * Runs the session with the provided input and run-time configuration.
     * Progress updates are forwarded to the supplied callback interface.
     */
    func run(input: SessionInput, runConfig: SessionRunConfig, progressCallback: SessionProgressHandler)  -> SessionOutput
    
}
open class Session: SessionProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_uzu_plus_fn_clone_session(self.pointer, $0) }
    }
public convenience init(modelDir: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeSessionError_lift) {
    uniffi_uzu_plus_fn_constructor_session_new(
        FfiConverterString.lower(modelDir),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_uzu_plus_fn_free_session(pointer, $0) }
    }

    

    
    /**
     * Loads the model configuration. Must be called before `run`.
     */
open func load(config: SessionConfig)throws   {try rustCallWithError(FfiConverterTypeSessionError_lift) {
    uniffi_uzu_plus_fn_method_session_load(self.uniffiClonePointer(),
        FfiConverterTypeSessionConfig_lower(config),$0
    )
}
}
    
    /**
     * Runs the session with the provided input and run-time configuration.
     * Progress updates are forwarded to the supplied callback interface.
     */
open func run(input: SessionInput, runConfig: SessionRunConfig, progressCallback: SessionProgressHandler) -> SessionOutput  {
    return try!  FfiConverterTypeSessionOutput_lift(try! rustCall() {
    uniffi_uzu_plus_fn_method_session_run(self.uniffiClonePointer(),
        FfiConverterTypeSessionInput_lower(input),
        FfiConverterTypeSessionRunConfig_lower(runConfig),
        FfiConverterCallbackInterfaceSessionProgressHandler_lower(progressCallback),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSession: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Session

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Session {
        return Session(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Session) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Session {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Session, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSession_lift(_ pointer: UnsafeMutableRawPointer) throws -> Session {
    return try FfiConverterTypeSession.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSession_lower(_ value: Session) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSession.lower(value)
}




public struct DecoderTestResult {
    public var placementLog: String
    public var iterations: UInt32
    public var timePerToken: Float
    public var tokensPerSecond: Float
    public var success: Bool
    public var error: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(placementLog: String, iterations: UInt32, timePerToken: Float, tokensPerSecond: Float, success: Bool, error: String?) {
        self.placementLog = placementLog
        self.iterations = iterations
        self.timePerToken = timePerToken
        self.tokensPerSecond = tokensPerSecond
        self.success = success
        self.error = error
    }
}

#if compiler(>=6)
extension DecoderTestResult: Sendable {}
#endif


extension DecoderTestResult: Equatable, Hashable {
    public static func ==(lhs: DecoderTestResult, rhs: DecoderTestResult) -> Bool {
        if lhs.placementLog != rhs.placementLog {
            return false
        }
        if lhs.iterations != rhs.iterations {
            return false
        }
        if lhs.timePerToken != rhs.timePerToken {
            return false
        }
        if lhs.tokensPerSecond != rhs.tokensPerSecond {
            return false
        }
        if lhs.success != rhs.success {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(placementLog)
        hasher.combine(iterations)
        hasher.combine(timePerToken)
        hasher.combine(tokensPerSecond)
        hasher.combine(success)
        hasher.combine(error)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDecoderTestResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DecoderTestResult {
        return
            try DecoderTestResult(
                placementLog: FfiConverterString.read(from: &buf), 
                iterations: FfiConverterUInt32.read(from: &buf), 
                timePerToken: FfiConverterFloat.read(from: &buf), 
                tokensPerSecond: FfiConverterFloat.read(from: &buf), 
                success: FfiConverterBool.read(from: &buf), 
                error: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: DecoderTestResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.placementLog, into: &buf)
        FfiConverterUInt32.write(value.iterations, into: &buf)
        FfiConverterFloat.write(value.timePerToken, into: &buf)
        FfiConverterFloat.write(value.tokensPerSecond, into: &buf)
        FfiConverterBool.write(value.success, into: &buf)
        FfiConverterOptionString.write(value.error, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDecoderTestResult_lift(_ buf: RustBuffer) throws -> DecoderTestResult {
    return try FfiConverterTypeDecoderTestResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDecoderTestResult_lower(_ value: DecoderTestResult) -> RustBuffer {
    return FfiConverterTypeDecoderTestResult.lower(value)
}


public struct Model {
    /**
     * Unique identifier of the model in the form `<vendor>-<name>-<precision>`.
     */
    public var identifier: String
    /**
     * Vendor/author of the model (e.g. "Llama").
     */
    public var vendor: String
    /**
     * Human-readable model name without vendor/precision (e.g. "3B-Instruct").
     */
    public var name: String
    /**
     * Numerical precision of the weights (e.g. "float16").
     */
    public var precision: String
    /**
     * Current download/installation state.
     */
    public var state: ModelState

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique identifier of the model in the form `<vendor>-<name>-<precision>`.
         */identifier: String, 
        /**
         * Vendor/author of the model (e.g. "Llama").
         */vendor: String, 
        /**
         * Human-readable model name without vendor/precision (e.g. "3B-Instruct").
         */name: String, 
        /**
         * Numerical precision of the weights (e.g. "float16").
         */precision: String, 
        /**
         * Current download/installation state.
         */state: ModelState) {
        self.identifier = identifier
        self.vendor = vendor
        self.name = name
        self.precision = precision
        self.state = state
    }
}

#if compiler(>=6)
extension Model: Sendable {}
#endif


extension Model: Equatable, Hashable {
    public static func ==(lhs: Model, rhs: Model) -> Bool {
        if lhs.identifier != rhs.identifier {
            return false
        }
        if lhs.vendor != rhs.vendor {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.precision != rhs.precision {
            return false
        }
        if lhs.state != rhs.state {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identifier)
        hasher.combine(vendor)
        hasher.combine(name)
        hasher.combine(precision)
        hasher.combine(state)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeModel: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Model {
        return
            try Model(
                identifier: FfiConverterString.read(from: &buf), 
                vendor: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                precision: FfiConverterString.read(from: &buf), 
                state: FfiConverterTypeModelState.read(from: &buf)
        )
    }

    public static func write(_ value: Model, into buf: inout [UInt8]) {
        FfiConverterString.write(value.identifier, into: &buf)
        FfiConverterString.write(value.vendor, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.precision, into: &buf)
        FfiConverterTypeModelState.write(value.state, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeModel_lift(_ buf: RustBuffer) throws -> Model {
    return try FfiConverterTypeModel.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeModel_lower(_ value: Model) -> RustBuffer {
    return FfiConverterTypeModel.lower(value)
}


public struct SessionClassificationFeature {
    public var name: String
    public var values: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, values: [String]) {
        self.name = name
        self.values = values
    }
}

#if compiler(>=6)
extension SessionClassificationFeature: Sendable {}
#endif


extension SessionClassificationFeature: Equatable, Hashable {
    public static func ==(lhs: SessionClassificationFeature, rhs: SessionClassificationFeature) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.values != rhs.values {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(values)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSessionClassificationFeature: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionClassificationFeature {
        return
            try SessionClassificationFeature(
                name: FfiConverterString.read(from: &buf), 
                values: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: SessionClassificationFeature, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterSequenceString.write(value.values, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionClassificationFeature_lift(_ buf: RustBuffer) throws -> SessionClassificationFeature {
    return try FfiConverterTypeSessionClassificationFeature.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionClassificationFeature_lower(_ value: SessionClassificationFeature) -> RustBuffer {
    return FfiConverterTypeSessionClassificationFeature.lower(value)
}


public struct SessionConfig {
    public var preset: SessionPreset
    public var samplingSeed: SamplingSeed
    public var contextLength: ContextLength

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(preset: SessionPreset, samplingSeed: SamplingSeed, contextLength: ContextLength) {
        self.preset = preset
        self.samplingSeed = samplingSeed
        self.contextLength = contextLength
    }
}

#if compiler(>=6)
extension SessionConfig: Sendable {}
#endif


extension SessionConfig: Equatable, Hashable {
    public static func ==(lhs: SessionConfig, rhs: SessionConfig) -> Bool {
        if lhs.preset != rhs.preset {
            return false
        }
        if lhs.samplingSeed != rhs.samplingSeed {
            return false
        }
        if lhs.contextLength != rhs.contextLength {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(preset)
        hasher.combine(samplingSeed)
        hasher.combine(contextLength)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSessionConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionConfig {
        return
            try SessionConfig(
                preset: FfiConverterTypeSessionPreset.read(from: &buf), 
                samplingSeed: FfiConverterTypeSamplingSeed.read(from: &buf), 
                contextLength: FfiConverterTypeContextLength.read(from: &buf)
        )
    }

    public static func write(_ value: SessionConfig, into buf: inout [UInt8]) {
        FfiConverterTypeSessionPreset.write(value.preset, into: &buf)
        FfiConverterTypeSamplingSeed.write(value.samplingSeed, into: &buf)
        FfiConverterTypeContextLength.write(value.contextLength, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionConfig_lift(_ buf: RustBuffer) throws -> SessionConfig {
    return try FfiConverterTypeSessionConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionConfig_lower(_ value: SessionConfig) -> RustBuffer {
    return FfiConverterTypeSessionConfig.lower(value)
}


public struct SessionMessage {
    public var role: SessionMessageRole
    public var content: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(role: SessionMessageRole, content: String) {
        self.role = role
        self.content = content
    }
}

#if compiler(>=6)
extension SessionMessage: Sendable {}
#endif


extension SessionMessage: Equatable, Hashable {
    public static func ==(lhs: SessionMessage, rhs: SessionMessage) -> Bool {
        if lhs.role != rhs.role {
            return false
        }
        if lhs.content != rhs.content {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(role)
        hasher.combine(content)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSessionMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionMessage {
        return
            try SessionMessage(
                role: FfiConverterTypeSessionMessageRole.read(from: &buf), 
                content: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SessionMessage, into buf: inout [UInt8]) {
        FfiConverterTypeSessionMessageRole.write(value.role, into: &buf)
        FfiConverterString.write(value.content, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionMessage_lift(_ buf: RustBuffer) throws -> SessionMessage {
    return try FfiConverterTypeSessionMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionMessage_lower(_ value: SessionMessage) -> RustBuffer {
    return FfiConverterTypeSessionMessage.lower(value)
}


public struct SessionOutput {
    public var text: String
    public var stats: SessionOutputStats
    public var finishReason: SessionOutputFinishReason?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(text: String, stats: SessionOutputStats, finishReason: SessionOutputFinishReason?) {
        self.text = text
        self.stats = stats
        self.finishReason = finishReason
    }
}

#if compiler(>=6)
extension SessionOutput: Sendable {}
#endif


extension SessionOutput: Equatable, Hashable {
    public static func ==(lhs: SessionOutput, rhs: SessionOutput) -> Bool {
        if lhs.text != rhs.text {
            return false
        }
        if lhs.stats != rhs.stats {
            return false
        }
        if lhs.finishReason != rhs.finishReason {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(text)
        hasher.combine(stats)
        hasher.combine(finishReason)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSessionOutput: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionOutput {
        return
            try SessionOutput(
                text: FfiConverterString.read(from: &buf), 
                stats: FfiConverterTypeSessionOutputStats.read(from: &buf), 
                finishReason: FfiConverterOptionTypeSessionOutputFinishReason.read(from: &buf)
        )
    }

    public static func write(_ value: SessionOutput, into buf: inout [UInt8]) {
        FfiConverterString.write(value.text, into: &buf)
        FfiConverterTypeSessionOutputStats.write(value.stats, into: &buf)
        FfiConverterOptionTypeSessionOutputFinishReason.write(value.finishReason, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionOutput_lift(_ buf: RustBuffer) throws -> SessionOutput {
    return try FfiConverterTypeSessionOutput.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionOutput_lower(_ value: SessionOutput) -> RustBuffer {
    return FfiConverterTypeSessionOutput.lower(value)
}


public struct SessionOutputRunStats {
    public var count: UInt64
    public var averageDuration: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(count: UInt64, averageDuration: Double) {
        self.count = count
        self.averageDuration = averageDuration
    }
}

#if compiler(>=6)
extension SessionOutputRunStats: Sendable {}
#endif


extension SessionOutputRunStats: Equatable, Hashable {
    public static func ==(lhs: SessionOutputRunStats, rhs: SessionOutputRunStats) -> Bool {
        if lhs.count != rhs.count {
            return false
        }
        if lhs.averageDuration != rhs.averageDuration {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(count)
        hasher.combine(averageDuration)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSessionOutputRunStats: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionOutputRunStats {
        return
            try SessionOutputRunStats(
                count: FfiConverterUInt64.read(from: &buf), 
                averageDuration: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: SessionOutputRunStats, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.count, into: &buf)
        FfiConverterDouble.write(value.averageDuration, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionOutputRunStats_lift(_ buf: RustBuffer) throws -> SessionOutputRunStats {
    return try FfiConverterTypeSessionOutputRunStats.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionOutputRunStats_lower(_ value: SessionOutputRunStats) -> RustBuffer {
    return FfiConverterTypeSessionOutputRunStats.lower(value)
}


public struct SessionOutputStats {
    public var prefillStats: SessionOutputStepStats
    public var generateStats: SessionOutputStepStats?
    public var totalStats: SessionOutputTotalStats

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(prefillStats: SessionOutputStepStats, generateStats: SessionOutputStepStats?, totalStats: SessionOutputTotalStats) {
        self.prefillStats = prefillStats
        self.generateStats = generateStats
        self.totalStats = totalStats
    }
}

#if compiler(>=6)
extension SessionOutputStats: Sendable {}
#endif


extension SessionOutputStats: Equatable, Hashable {
    public static func ==(lhs: SessionOutputStats, rhs: SessionOutputStats) -> Bool {
        if lhs.prefillStats != rhs.prefillStats {
            return false
        }
        if lhs.generateStats != rhs.generateStats {
            return false
        }
        if lhs.totalStats != rhs.totalStats {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(prefillStats)
        hasher.combine(generateStats)
        hasher.combine(totalStats)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSessionOutputStats: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionOutputStats {
        return
            try SessionOutputStats(
                prefillStats: FfiConverterTypeSessionOutputStepStats.read(from: &buf), 
                generateStats: FfiConverterOptionTypeSessionOutputStepStats.read(from: &buf), 
                totalStats: FfiConverterTypeSessionOutputTotalStats.read(from: &buf)
        )
    }

    public static func write(_ value: SessionOutputStats, into buf: inout [UInt8]) {
        FfiConverterTypeSessionOutputStepStats.write(value.prefillStats, into: &buf)
        FfiConverterOptionTypeSessionOutputStepStats.write(value.generateStats, into: &buf)
        FfiConverterTypeSessionOutputTotalStats.write(value.totalStats, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionOutputStats_lift(_ buf: RustBuffer) throws -> SessionOutputStats {
    return try FfiConverterTypeSessionOutputStats.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionOutputStats_lower(_ value: SessionOutputStats) -> RustBuffer {
    return FfiConverterTypeSessionOutputStats.lower(value)
}


public struct SessionOutputStepStats {
    public var duration: Double
    public var suffixLength: UInt64
    public var tokensCount: UInt64
    public var tokensPerSecond: Double
    public var modelRun: SessionOutputRunStats
    public var run: SessionOutputRunStats?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(duration: Double, suffixLength: UInt64, tokensCount: UInt64, tokensPerSecond: Double, modelRun: SessionOutputRunStats, run: SessionOutputRunStats?) {
        self.duration = duration
        self.suffixLength = suffixLength
        self.tokensCount = tokensCount
        self.tokensPerSecond = tokensPerSecond
        self.modelRun = modelRun
        self.run = run
    }
}

#if compiler(>=6)
extension SessionOutputStepStats: Sendable {}
#endif


extension SessionOutputStepStats: Equatable, Hashable {
    public static func ==(lhs: SessionOutputStepStats, rhs: SessionOutputStepStats) -> Bool {
        if lhs.duration != rhs.duration {
            return false
        }
        if lhs.suffixLength != rhs.suffixLength {
            return false
        }
        if lhs.tokensCount != rhs.tokensCount {
            return false
        }
        if lhs.tokensPerSecond != rhs.tokensPerSecond {
            return false
        }
        if lhs.modelRun != rhs.modelRun {
            return false
        }
        if lhs.run != rhs.run {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(duration)
        hasher.combine(suffixLength)
        hasher.combine(tokensCount)
        hasher.combine(tokensPerSecond)
        hasher.combine(modelRun)
        hasher.combine(run)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSessionOutputStepStats: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionOutputStepStats {
        return
            try SessionOutputStepStats(
                duration: FfiConverterDouble.read(from: &buf), 
                suffixLength: FfiConverterUInt64.read(from: &buf), 
                tokensCount: FfiConverterUInt64.read(from: &buf), 
                tokensPerSecond: FfiConverterDouble.read(from: &buf), 
                modelRun: FfiConverterTypeSessionOutputRunStats.read(from: &buf), 
                run: FfiConverterOptionTypeSessionOutputRunStats.read(from: &buf)
        )
    }

    public static func write(_ value: SessionOutputStepStats, into buf: inout [UInt8]) {
        FfiConverterDouble.write(value.duration, into: &buf)
        FfiConverterUInt64.write(value.suffixLength, into: &buf)
        FfiConverterUInt64.write(value.tokensCount, into: &buf)
        FfiConverterDouble.write(value.tokensPerSecond, into: &buf)
        FfiConverterTypeSessionOutputRunStats.write(value.modelRun, into: &buf)
        FfiConverterOptionTypeSessionOutputRunStats.write(value.run, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionOutputStepStats_lift(_ buf: RustBuffer) throws -> SessionOutputStepStats {
    return try FfiConverterTypeSessionOutputStepStats.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionOutputStepStats_lower(_ value: SessionOutputStepStats) -> RustBuffer {
    return FfiConverterTypeSessionOutputStepStats.lower(value)
}


public struct SessionOutputTotalStats {
    public var duration: Double
    public var tokensCountInput: UInt64
    public var tokensCountOutput: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(duration: Double, tokensCountInput: UInt64, tokensCountOutput: UInt64) {
        self.duration = duration
        self.tokensCountInput = tokensCountInput
        self.tokensCountOutput = tokensCountOutput
    }
}

#if compiler(>=6)
extension SessionOutputTotalStats: Sendable {}
#endif


extension SessionOutputTotalStats: Equatable, Hashable {
    public static func ==(lhs: SessionOutputTotalStats, rhs: SessionOutputTotalStats) -> Bool {
        if lhs.duration != rhs.duration {
            return false
        }
        if lhs.tokensCountInput != rhs.tokensCountInput {
            return false
        }
        if lhs.tokensCountOutput != rhs.tokensCountOutput {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(duration)
        hasher.combine(tokensCountInput)
        hasher.combine(tokensCountOutput)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSessionOutputTotalStats: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionOutputTotalStats {
        return
            try SessionOutputTotalStats(
                duration: FfiConverterDouble.read(from: &buf), 
                tokensCountInput: FfiConverterUInt64.read(from: &buf), 
                tokensCountOutput: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SessionOutputTotalStats, into buf: inout [UInt8]) {
        FfiConverterDouble.write(value.duration, into: &buf)
        FfiConverterUInt64.write(value.tokensCountInput, into: &buf)
        FfiConverterUInt64.write(value.tokensCountOutput, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionOutputTotalStats_lift(_ buf: RustBuffer) throws -> SessionOutputTotalStats {
    return try FfiConverterTypeSessionOutputTotalStats.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionOutputTotalStats_lower(_ value: SessionOutputTotalStats) -> RustBuffer {
    return FfiConverterTypeSessionOutputTotalStats.lower(value)
}


public struct SessionRunConfig {
    public var tokensLimit: UInt64
    public var samplingMethod: SamplingConfig

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(tokensLimit: UInt64, samplingMethod: SamplingConfig) {
        self.tokensLimit = tokensLimit
        self.samplingMethod = samplingMethod
    }
}

#if compiler(>=6)
extension SessionRunConfig: Sendable {}
#endif


extension SessionRunConfig: Equatable, Hashable {
    public static func ==(lhs: SessionRunConfig, rhs: SessionRunConfig) -> Bool {
        if lhs.tokensLimit != rhs.tokensLimit {
            return false
        }
        if lhs.samplingMethod != rhs.samplingMethod {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(tokensLimit)
        hasher.combine(samplingMethod)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSessionRunConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionRunConfig {
        return
            try SessionRunConfig(
                tokensLimit: FfiConverterUInt64.read(from: &buf), 
                samplingMethod: FfiConverterTypeSamplingConfig.read(from: &buf)
        )
    }

    public static func write(_ value: SessionRunConfig, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.tokensLimit, into: &buf)
        FfiConverterTypeSamplingConfig.write(value.samplingMethod, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionRunConfig_lift(_ buf: RustBuffer) throws -> SessionRunConfig {
    return try FfiConverterTypeSessionRunConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionRunConfig_lower(_ value: SessionRunConfig) -> RustBuffer {
    return FfiConverterTypeSessionRunConfig.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ContextLength {
    
    case `default`
    case custom(UInt64
    )
}


#if compiler(>=6)
extension ContextLength: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeContextLength: FfiConverterRustBuffer {
    typealias SwiftType = ContextLength

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContextLength {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`default`
        
        case 2: return .custom(try FfiConverterUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ContextLength, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`default`:
            writeInt(&buf, Int32(1))
        
        
        case let .custom(v1):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContextLength_lift(_ buf: RustBuffer) throws -> ContextLength {
    return try FfiConverterTypeContextLength.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContextLength_lower(_ value: ContextLength) -> RustBuffer {
    return FfiConverterTypeContextLength.lower(value)
}


extension ContextLength: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DownloadProgress {
    
    case started(fileName: String, totalSize: UInt64?
    )
    case advanced(fileName: String, downloadedBytes: UInt64, totalSize: UInt64?
    )
    case paused(fileName: String, downloadedBytes: UInt64, totalSize: UInt64?
    )
    case completed(fileName: String, totalBytes: UInt64, localPath: LocalPath
    )
    case error(fileName: String, message: String
    )
}


#if compiler(>=6)
extension DownloadProgress: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDownloadProgress: FfiConverterRustBuffer {
    typealias SwiftType = DownloadProgress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DownloadProgress {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .started(fileName: try FfiConverterString.read(from: &buf), totalSize: try FfiConverterOptionUInt64.read(from: &buf)
        )
        
        case 2: return .advanced(fileName: try FfiConverterString.read(from: &buf), downloadedBytes: try FfiConverterUInt64.read(from: &buf), totalSize: try FfiConverterOptionUInt64.read(from: &buf)
        )
        
        case 3: return .paused(fileName: try FfiConverterString.read(from: &buf), downloadedBytes: try FfiConverterUInt64.read(from: &buf), totalSize: try FfiConverterOptionUInt64.read(from: &buf)
        )
        
        case 4: return .completed(fileName: try FfiConverterString.read(from: &buf), totalBytes: try FfiConverterUInt64.read(from: &buf), localPath: try FfiConverterTypeLocalPath.read(from: &buf)
        )
        
        case 5: return .error(fileName: try FfiConverterString.read(from: &buf), message: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DownloadProgress, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .started(fileName,totalSize):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(fileName, into: &buf)
            FfiConverterOptionUInt64.write(totalSize, into: &buf)
            
        
        case let .advanced(fileName,downloadedBytes,totalSize):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(fileName, into: &buf)
            FfiConverterUInt64.write(downloadedBytes, into: &buf)
            FfiConverterOptionUInt64.write(totalSize, into: &buf)
            
        
        case let .paused(fileName,downloadedBytes,totalSize):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(fileName, into: &buf)
            FfiConverterUInt64.write(downloadedBytes, into: &buf)
            FfiConverterOptionUInt64.write(totalSize, into: &buf)
            
        
        case let .completed(fileName,totalBytes,localPath):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(fileName, into: &buf)
            FfiConverterUInt64.write(totalBytes, into: &buf)
            FfiConverterTypeLocalPath.write(localPath, into: &buf)
            
        
        case let .error(fileName,message):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(fileName, into: &buf)
            FfiConverterString.write(message, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDownloadProgress_lift(_ buf: RustBuffer) throws -> DownloadProgress {
    return try FfiConverterTypeDownloadProgress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDownloadProgress_lower(_ value: DownloadProgress) -> RustBuffer {
    return FfiConverterTypeDownloadProgress.lower(value)
}


extension DownloadProgress: Equatable, Hashable {}




public enum DownloaderError: Swift.Error {

    
    
    case Http(message: String)
    
    case Io(message: String)
    
    case AlreadyExists(message: String)
    
    case Generic(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDownloaderError: FfiConverterRustBuffer {
    typealias SwiftType = DownloaderError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DownloaderError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Http(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .Io(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .AlreadyExists(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DownloaderError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Http(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .Io(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .AlreadyExists(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDownloaderError_lift(_ buf: RustBuffer) throws -> DownloaderError {
    return try FfiConverterTypeDownloaderError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDownloaderError_lower(_ value: DownloaderError) -> RustBuffer {
    return FfiConverterTypeDownloaderError.lower(value)
}


extension DownloaderError: Equatable, Hashable {}





public enum Error: Swift.Error {

    
    
    case Storage(StorageError
    )
    case Downloader(DownloaderError
    )
    case Session(SessionError
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeError: FfiConverterRustBuffer {
    typealias SwiftType = Error

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Error {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Storage(
            try FfiConverterTypeStorageError.read(from: &buf)
            )
        case 2: return .Downloader(
            try FfiConverterTypeDownloaderError.read(from: &buf)
            )
        case 3: return .Session(
            try FfiConverterTypeSessionError.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Error, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Storage(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeStorageError.write(v1, into: &buf)
            
        
        case let .Downloader(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeDownloaderError.write(v1, into: &buf)
            
        
        case let .Session(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeSessionError.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeError_lift(_ buf: RustBuffer) throws -> Error {
    return try FfiConverterTypeError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeError_lower(_ value: Error) -> RustBuffer {
    return FfiConverterTypeError.lower(value)
}


extension Error: Equatable, Hashable {}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LicenseStatus {
    
    case notActivated
    case gracePeriodActive
    case activated
    case networkError
    case invalidApiKey
    case signatureMismatch
    /**
     * The HTTP request timed out before receiving a response.
     */
    case timeout
    /**
     * The server responded with a non-success HTTP status code (e.g. 404, 429, 500 …).
     */
    case httpError(code: UInt16
    )
}


#if compiler(>=6)
extension LicenseStatus: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLicenseStatus: FfiConverterRustBuffer {
    typealias SwiftType = LicenseStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LicenseStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .notActivated
        
        case 2: return .gracePeriodActive
        
        case 3: return .activated
        
        case 4: return .networkError
        
        case 5: return .invalidApiKey
        
        case 6: return .signatureMismatch
        
        case 7: return .timeout
        
        case 8: return .httpError(code: try FfiConverterUInt16.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LicenseStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .notActivated:
            writeInt(&buf, Int32(1))
        
        
        case .gracePeriodActive:
            writeInt(&buf, Int32(2))
        
        
        case .activated:
            writeInt(&buf, Int32(3))
        
        
        case .networkError:
            writeInt(&buf, Int32(4))
        
        
        case .invalidApiKey:
            writeInt(&buf, Int32(5))
        
        
        case .signatureMismatch:
            writeInt(&buf, Int32(6))
        
        
        case .timeout:
            writeInt(&buf, Int32(7))
        
        
        case let .httpError(code):
            writeInt(&buf, Int32(8))
            FfiConverterUInt16.write(code, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLicenseStatus_lift(_ buf: RustBuffer) throws -> LicenseStatus {
    return try FfiConverterTypeLicenseStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLicenseStatus_lower(_ value: LicenseStatus) -> RustBuffer {
    return FfiConverterTypeLicenseStatus.lower(value)
}


extension LicenseStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * High-level model download state exposed to Swift.
 */

public enum ModelState {
    
    case notDownloaded
    case downloading(progress: Double
    )
    case paused(progress: Double
    )
    case downloaded
    case error(error: Error
    )
}


#if compiler(>=6)
extension ModelState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeModelState: FfiConverterRustBuffer {
    typealias SwiftType = ModelState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ModelState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .notDownloaded
        
        case 2: return .downloading(progress: try FfiConverterDouble.read(from: &buf)
        )
        
        case 3: return .paused(progress: try FfiConverterDouble.read(from: &buf)
        )
        
        case 4: return .downloaded
        
        case 5: return .error(error: try FfiConverterTypeError.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ModelState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .notDownloaded:
            writeInt(&buf, Int32(1))
        
        
        case let .downloading(progress):
            writeInt(&buf, Int32(2))
            FfiConverterDouble.write(progress, into: &buf)
            
        
        case let .paused(progress):
            writeInt(&buf, Int32(3))
            FfiConverterDouble.write(progress, into: &buf)
            
        
        case .downloaded:
            writeInt(&buf, Int32(4))
        
        
        case let .error(error):
            writeInt(&buf, Int32(5))
            FfiConverterTypeError.write(error, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeModelState_lift(_ buf: RustBuffer) throws -> ModelState {
    return try FfiConverterTypeModelState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeModelState_lower(_ value: ModelState) -> RustBuffer {
    return FfiConverterTypeModelState.lower(value)
}


extension ModelState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SamplingConfig {
    
    case argmax
    case topP(topP: Float
    )
    case categorical(temperature: Float
    )
}


#if compiler(>=6)
extension SamplingConfig: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSamplingConfig: FfiConverterRustBuffer {
    typealias SwiftType = SamplingConfig

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SamplingConfig {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .argmax
        
        case 2: return .topP(topP: try FfiConverterFloat.read(from: &buf)
        )
        
        case 3: return .categorical(temperature: try FfiConverterFloat.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SamplingConfig, into buf: inout [UInt8]) {
        switch value {
        
        
        case .argmax:
            writeInt(&buf, Int32(1))
        
        
        case let .topP(topP):
            writeInt(&buf, Int32(2))
            FfiConverterFloat.write(topP, into: &buf)
            
        
        case let .categorical(temperature):
            writeInt(&buf, Int32(3))
            FfiConverterFloat.write(temperature, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSamplingConfig_lift(_ buf: RustBuffer) throws -> SamplingConfig {
    return try FfiConverterTypeSamplingConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSamplingConfig_lower(_ value: SamplingConfig) -> RustBuffer {
    return FfiConverterTypeSamplingConfig.lower(value)
}


extension SamplingConfig: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SamplingSeed {
    
    case `default`
    case custom(UInt64
    )
}


#if compiler(>=6)
extension SamplingSeed: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSamplingSeed: FfiConverterRustBuffer {
    typealias SwiftType = SamplingSeed

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SamplingSeed {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`default`
        
        case 2: return .custom(try FfiConverterUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SamplingSeed, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`default`:
            writeInt(&buf, Int32(1))
        
        
        case let .custom(v1):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSamplingSeed_lift(_ buf: RustBuffer) throws -> SamplingSeed {
    return try FfiConverterTypeSamplingSeed.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSamplingSeed_lower(_ value: SamplingSeed) -> RustBuffer {
    return FfiConverterTypeSamplingSeed.lower(value)
}


extension SamplingSeed: Equatable, Hashable {}




public enum SessionError: Swift.Error {

    
    
    case UnableToCreateMetalContext
    case UnableToLoadConfig
    case UnableToLoadWeights
    case UnableToLoadTokenizerConfig
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSessionError: FfiConverterRustBuffer {
    typealias SwiftType = SessionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .UnableToCreateMetalContext
        case 2: return .UnableToLoadConfig
        case 3: return .UnableToLoadWeights
        case 4: return .UnableToLoadTokenizerConfig

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SessionError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .UnableToCreateMetalContext:
            writeInt(&buf, Int32(1))
        
        
        case .UnableToLoadConfig:
            writeInt(&buf, Int32(2))
        
        
        case .UnableToLoadWeights:
            writeInt(&buf, Int32(3))
        
        
        case .UnableToLoadTokenizerConfig:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionError_lift(_ buf: RustBuffer) throws -> SessionError {
    return try FfiConverterTypeSessionError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionError_lower(_ value: SessionError) -> RustBuffer {
    return FfiConverterTypeSessionError.lower(value)
}


extension SessionError: Equatable, Hashable {}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SessionInput {
    
    case text(String
    )
    case messages([SessionMessage]
    )
}


#if compiler(>=6)
extension SessionInput: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSessionInput: FfiConverterRustBuffer {
    typealias SwiftType = SessionInput

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionInput {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .text(try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .messages(try FfiConverterSequenceTypeSessionMessage.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SessionInput, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .text(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .messages(v1):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeSessionMessage.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionInput_lift(_ buf: RustBuffer) throws -> SessionInput {
    return try FfiConverterTypeSessionInput.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionInput_lower(_ value: SessionInput) -> RustBuffer {
    return FfiConverterTypeSessionInput.lower(value)
}


extension SessionInput: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SessionMessageRole {
    
    case system
    case user
    case assistant
}


#if compiler(>=6)
extension SessionMessageRole: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSessionMessageRole: FfiConverterRustBuffer {
    typealias SwiftType = SessionMessageRole

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionMessageRole {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .system
        
        case 2: return .user
        
        case 3: return .assistant
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SessionMessageRole, into buf: inout [UInt8]) {
        switch value {
        
        
        case .system:
            writeInt(&buf, Int32(1))
        
        
        case .user:
            writeInt(&buf, Int32(2))
        
        
        case .assistant:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionMessageRole_lift(_ buf: RustBuffer) throws -> SessionMessageRole {
    return try FfiConverterTypeSessionMessageRole.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionMessageRole_lower(_ value: SessionMessageRole) -> RustBuffer {
    return FfiConverterTypeSessionMessageRole.lower(value)
}


extension SessionMessageRole: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SessionOutputFinishReason {
    
    case stop
    case length
    case cancelled
}


#if compiler(>=6)
extension SessionOutputFinishReason: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSessionOutputFinishReason: FfiConverterRustBuffer {
    typealias SwiftType = SessionOutputFinishReason

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionOutputFinishReason {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .stop
        
        case 2: return .length
        
        case 3: return .cancelled
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SessionOutputFinishReason, into buf: inout [UInt8]) {
        switch value {
        
        
        case .stop:
            writeInt(&buf, Int32(1))
        
        
        case .length:
            writeInt(&buf, Int32(2))
        
        
        case .cancelled:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionOutputFinishReason_lift(_ buf: RustBuffer) throws -> SessionOutputFinishReason {
    return try FfiConverterTypeSessionOutputFinishReason.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionOutputFinishReason_lower(_ value: SessionOutputFinishReason) -> RustBuffer {
    return FfiConverterTypeSessionOutputFinishReason.lower(value)
}


extension SessionOutputFinishReason: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SessionPreset {
    
    case general
    case classification(SessionClassificationFeature
    )
    case summarization
}


#if compiler(>=6)
extension SessionPreset: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSessionPreset: FfiConverterRustBuffer {
    typealias SwiftType = SessionPreset

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionPreset {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .general
        
        case 2: return .classification(try FfiConverterTypeSessionClassificationFeature.read(from: &buf)
        )
        
        case 3: return .summarization
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SessionPreset, into buf: inout [UInt8]) {
        switch value {
        
        
        case .general:
            writeInt(&buf, Int32(1))
        
        
        case let .classification(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSessionClassificationFeature.write(v1, into: &buf)
            
        
        case .summarization:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionPreset_lift(_ buf: RustBuffer) throws -> SessionPreset {
    return try FfiConverterTypeSessionPreset.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionPreset_lower(_ value: SessionPreset) -> RustBuffer {
    return FfiConverterTypeSessionPreset.lower(value)
}


extension SessionPreset: Equatable, Hashable {}




public enum StorageError: Swift.Error {

    
    
    case ModelNotDownloaded
    case UnknownModel(identifier: String
    )
    case Storage(message: String
    )
    case MutexPoisoned(message: String
    )
    case LicenseNotActivated
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStorageError: FfiConverterRustBuffer {
    typealias SwiftType = StorageError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StorageError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ModelNotDownloaded
        case 2: return .UnknownModel(
            identifier: try FfiConverterString.read(from: &buf)
            )
        case 3: return .Storage(
            message: try FfiConverterString.read(from: &buf)
            )
        case 4: return .MutexPoisoned(
            message: try FfiConverterString.read(from: &buf)
            )
        case 5: return .LicenseNotActivated

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: StorageError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .ModelNotDownloaded:
            writeInt(&buf, Int32(1))
        
        
        case let .UnknownModel(identifier):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(identifier, into: &buf)
            
        
        case let .Storage(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .MutexPoisoned(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
            
        
        case .LicenseNotActivated:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStorageError_lift(_ buf: RustBuffer) throws -> StorageError {
    return try FfiConverterTypeStorageError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStorageError_lower(_ value: StorageError) -> RustBuffer {
    return FfiConverterTypeStorageError.lower(value)
}


extension StorageError: Equatable, Hashable {}







/**
 * Callback interface Swift implements to react to license status changes.
 */
public protocol LicenseStatusHandler: AnyObject, Sendable {
    
    func onStatus(status: LicenseStatus) 
    
}
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceLicenseStatusHandler {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceLicenseStatusHandler] = [UniffiVTableCallbackInterfaceLicenseStatusHandler(
        onStatus: { (
            uniffiHandle: UInt64,
            status: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceLicenseStatusHandler.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onStatus(
                     status: try FfiConverterTypeLicenseStatus_lift(status)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceLicenseStatusHandler.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface LicenseStatusHandler: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitLicenseStatusHandler() {
    uniffi_uzu_plus_fn_init_callback_vtable_licensestatushandler(UniffiCallbackInterfaceLicenseStatusHandler.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceLicenseStatusHandler {
    fileprivate static let handleMap = UniffiHandleMap<LicenseStatusHandler>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceLicenseStatusHandler : FfiConverter {
    typealias SwiftType = LicenseStatusHandler
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceLicenseStatusHandler_lift(_ handle: UInt64) throws -> LicenseStatusHandler {
    return try FfiConverterCallbackInterfaceLicenseStatusHandler.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceLicenseStatusHandler_lower(_ v: LicenseStatusHandler) -> UInt64 {
    return FfiConverterCallbackInterfaceLicenseStatusHandler.lower(v)
}




/**
 * Callback interface Swift implements to react to state changes.
 */
public protocol ModelStateHandler: AnyObject, Sendable {
    
    func onState(identifier: String, state: ModelState) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceModelStateHandler {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceModelStateHandler] = [UniffiVTableCallbackInterfaceModelStateHandler(
        onState: { (
            uniffiHandle: UInt64,
            identifier: RustBuffer,
            state: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceModelStateHandler.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onState(
                     identifier: try FfiConverterString.lift(identifier),
                     state: try FfiConverterTypeModelState_lift(state)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceModelStateHandler.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface ModelStateHandler: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitModelStateHandler() {
    uniffi_uzu_plus_fn_init_callback_vtable_modelstatehandler(UniffiCallbackInterfaceModelStateHandler.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceModelStateHandler {
    fileprivate static let handleMap = UniffiHandleMap<ModelStateHandler>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceModelStateHandler : FfiConverter {
    typealias SwiftType = ModelStateHandler
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceModelStateHandler_lift(_ handle: UInt64) throws -> ModelStateHandler {
    return try FfiConverterCallbackInterfaceModelStateHandler.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceModelStateHandler_lower(_ v: ModelStateHandler) -> UInt64 {
    return FfiConverterCallbackInterfaceModelStateHandler.lower(v)
}




public protocol SessionProgressHandler: AnyObject, Sendable {
    
    func onProgress(output: SessionOutput)  -> Bool
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceSessionProgressHandler {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceSessionProgressHandler] = [UniffiVTableCallbackInterfaceSessionProgressHandler(
        onProgress: { (
            uniffiHandle: UInt64,
            output: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<Int8>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Bool in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSessionProgressHandler.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onProgress(
                     output: try FfiConverterTypeSessionOutput_lift(output)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterBool.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceSessionProgressHandler.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface SessionProgressHandler: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitSessionProgressHandler() {
    uniffi_uzu_plus_fn_init_callback_vtable_sessionprogresshandler(UniffiCallbackInterfaceSessionProgressHandler.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceSessionProgressHandler {
    fileprivate static let handleMap = UniffiHandleMap<SessionProgressHandler>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceSessionProgressHandler : FfiConverter {
    typealias SwiftType = SessionProgressHandler
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceSessionProgressHandler_lift(_ handle: UInt64) throws -> SessionProgressHandler {
    return try FfiConverterCallbackInterfaceSessionProgressHandler.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceSessionProgressHandler_lower(_ v: SessionProgressHandler) -> UInt64 {
    return FfiConverterCallbackInterfaceSessionProgressHandler.lower(v)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSessionOutputRunStats: FfiConverterRustBuffer {
    typealias SwiftType = SessionOutputRunStats?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSessionOutputRunStats.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSessionOutputRunStats.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSessionOutputStepStats: FfiConverterRustBuffer {
    typealias SwiftType = SessionOutputStepStats?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSessionOutputStepStats.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSessionOutputStepStats.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSessionOutputFinishReason: FfiConverterRustBuffer {
    typealias SwiftType = SessionOutputFinishReason?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSessionOutputFinishReason.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSessionOutputFinishReason.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeModel: FfiConverterRustBuffer {
    typealias SwiftType = [Model]

    public static func write(_ value: [Model], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeModel.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Model] {
        let len: Int32 = try readInt(&buf)
        var seq = [Model]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeModel.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeSessionMessage: FfiConverterRustBuffer {
    typealias SwiftType = [SessionMessage]

    public static func write(_ value: [SessionMessage], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSessionMessage.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SessionMessage] {
        let len: Int32 = try readInt(&buf)
        var seq = [SessionMessage]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSessionMessage.read(from: &buf))
        }
        return seq
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias LocalPath = String

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLocalPath: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocalPath {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: LocalPath, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> LocalPath {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: LocalPath) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocalPath_lift(_ value: RustBuffer) throws -> LocalPath {
    return try FfiConverterTypeLocalPath.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocalPath_lower(_ value: LocalPath) -> RustBuffer {
    return FfiConverterTypeLocalPath.lower(value)
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call the ensure init function since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureUzuPlusInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
/**
 * Synchronous wrapper around the async activation for Swift/Obj-C callers.
 */
public func activate(apiKey: String)  {try! rustCall() {
    uniffi_uzu_plus_fn_func_activate(
        FfiConverterString.lower(apiKey),$0
    )
}
}
public func errorUserDescription(err: Error) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_uzu_plus_fn_func_error_user_description(
        FfiConverterTypeError_lower(err),$0
    )
})
}
public func runDecoder(modelDir: String) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_uzu_plus_fn_func_run_decoder(
        FfiConverterString.lower(modelDir),$0
    )
})
}
public func runDecoderWithPlacementLog(modelDir: String) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_uzu_plus_fn_func_run_decoder_with_placement_log(
        FfiConverterString.lower(modelDir),$0
    )
})
}
public func runDecoderWithResults(modelDir: String) -> DecoderTestResult  {
    return try!  FfiConverterTypeDecoderTestResult_lift(try! rustCall() {
    uniffi_uzu_plus_fn_func_run_decoder_with_results(
        FfiConverterString.lower(modelDir),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_uzu_plus_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_uzu_plus_checksum_func_activate() != 37256) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_func_error_user_description() != 44999) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_func_run_decoder() != 59795) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_func_run_decoder_with_placement_log() != 36170) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_func_run_decoder_with_results() != 1653) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_engine_createsession() != 53834) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_engine_delete() != 9952) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_engine_download() != 54585) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_engine_getmodels() != 65529) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_engine_getstate() != 3690) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_engine_pause() != 33697) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_engine_registerlicensestatushandler() != 59511) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_engine_registermodelstatehandler() != 59291) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_engine_resume() != 4316) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_engine_set_state() != 61038) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_engine_stop() != 10696) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_engine_stop_internal() != 28417) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_engine_updateregistry() != 20444) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_session_load() != 9426) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_session_run() != 29021) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_constructor_engine_new() != 54904) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_constructor_session_new() != 44797) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_licensestatushandler_on_status() != 36495) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_modelstatehandler_on_state() != 22608) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_sessionprogresshandler_on_progress() != 37147) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitLicenseStatusHandler()
    uniffiCallbackInitModelStateHandler()
    uniffiCallbackInitSessionProgressHandler()
    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureUzuPlusInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all