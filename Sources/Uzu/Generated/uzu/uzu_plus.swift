// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(uzu_plusFFI)
import uzu_plusFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_uzu_plus_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_uzu_plus_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureUzuPlusInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}




/**
 * Thin FFI wrapper around `ModelStorage`.
 */
public protocol EngineProtocol: AnyObject, Sendable {
    
    func activate(apiKey: String) async throws  -> LicenseStatus
    
    func createSession(modelId: ModelId, config: Config) throws  -> Session
    
    func deleteModel(identifier: String) async throws 
    
    /**
     * Returns a `DownloadHandle` for the given model identifier.
     */
    func downloadHandle(identifier: String)  -> ModelDownloadHandle
    
    func downloadModel(identifier: String) async throws 
    
    func fetchCloudModels() async throws  -> [CloudModel]
    
    func getCloudModels() async throws  -> [CloudModel]
    
    func getLocalModels()  -> [LocalModel]
    
    func getState(identifier: String)  -> ModelDownloadState
    
    func pauseModel(identifier: String) async throws 
    
    /**
     * Register a callback that will receive cloud models snapshots.
     */
    func registerCloudModelsHandler(handler: CloudModelsHandler) 
    
    /**
     * Register a Rust callback that will receive license status updates.
     */
    func registerLicenseStatusHandler(handler: LicenseStatusHandler) 
    
    /**
     * Register a callback that will receive model state updates.
     */
    func registerModelStateHandler(handler: ModelStateHandler) 
    
}
/**
 * Thin FFI wrapper around `ModelStorage`.
 */
open class Engine: EngineProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_uzu_plus_fn_clone_engine(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_uzu_plus_fn_free_engine(pointer, $0) }
    }

    
public static func make() -> Engine  {
    return try!  FfiConverterTypeEngine_lift(try! rustCall() {
    uniffi_uzu_plus_fn_constructor_engine_make($0
    )
})
}
    

    
open func activate(apiKey: String)async throws  -> LicenseStatus  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_uzu_plus_fn_method_engine_activate(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(apiKey)
                )
            },
            pollFunc: ffi_uzu_plus_rust_future_poll_rust_buffer,
            completeFunc: ffi_uzu_plus_rust_future_complete_rust_buffer,
            freeFunc: ffi_uzu_plus_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeLicenseStatus_lift,
            errorHandler: FfiConverterTypeEngineError_lift
        )
}
    
open func createSession(modelId: ModelId, config: Config)throws  -> Session  {
    return try  FfiConverterTypeSession_lift(try rustCallWithError(FfiConverterTypeEngineError_lift) {
    uniffi_uzu_plus_fn_method_engine_createsession(self.uniffiClonePointer(),
        FfiConverterTypeModelID_lower(modelId),
        FfiConverterTypeConfig_lower(config),$0
    )
})
}
    
open func deleteModel(identifier: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_uzu_plus_fn_method_engine_delete_model(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(identifier)
                )
            },
            pollFunc: ffi_uzu_plus_rust_future_poll_void,
            completeFunc: ffi_uzu_plus_rust_future_complete_void,
            freeFunc: ffi_uzu_plus_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeEngineError_lift
        )
}
    
    /**
     * Returns a `DownloadHandle` for the given model identifier.
     */
open func downloadHandle(identifier: String) -> ModelDownloadHandle  {
    return try!  FfiConverterTypeModelDownloadHandle_lift(try! rustCall() {
    uniffi_uzu_plus_fn_method_engine_download_handle(self.uniffiClonePointer(),
        FfiConverterString.lower(identifier),$0
    )
})
}
    
open func downloadModel(identifier: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_uzu_plus_fn_method_engine_download_model(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(identifier)
                )
            },
            pollFunc: ffi_uzu_plus_rust_future_poll_void,
            completeFunc: ffi_uzu_plus_rust_future_complete_void,
            freeFunc: ffi_uzu_plus_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeEngineError_lift
        )
}
    
open func fetchCloudModels()async throws  -> [CloudModel]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_uzu_plus_fn_method_engine_fetch_cloud_models(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_uzu_plus_rust_future_poll_rust_buffer,
            completeFunc: ffi_uzu_plus_rust_future_complete_rust_buffer,
            freeFunc: ffi_uzu_plus_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeCloudModel.lift,
            errorHandler: FfiConverterTypeEngineError_lift
        )
}
    
open func getCloudModels()async throws  -> [CloudModel]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_uzu_plus_fn_method_engine_get_cloud_models(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_uzu_plus_rust_future_poll_rust_buffer,
            completeFunc: ffi_uzu_plus_rust_future_complete_rust_buffer,
            freeFunc: ffi_uzu_plus_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeCloudModel.lift,
            errorHandler: FfiConverterTypeEngineError_lift
        )
}
    
open func getLocalModels() -> [LocalModel]  {
    return try!  FfiConverterSequenceTypeLocalModel.lift(try! rustCall() {
    uniffi_uzu_plus_fn_method_engine_get_local_models(self.uniffiClonePointer(),$0
    )
})
}
    
open func getState(identifier: String) -> ModelDownloadState  {
    return try!  FfiConverterTypeModelDownloadState_lift(try! rustCall() {
    uniffi_uzu_plus_fn_method_engine_get_state(self.uniffiClonePointer(),
        FfiConverterString.lower(identifier),$0
    )
})
}
    
open func pauseModel(identifier: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_uzu_plus_fn_method_engine_pause_model(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(identifier)
                )
            },
            pollFunc: ffi_uzu_plus_rust_future_poll_void,
            completeFunc: ffi_uzu_plus_rust_future_complete_void,
            freeFunc: ffi_uzu_plus_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeEngineError_lift
        )
}
    
    /**
     * Register a callback that will receive cloud models snapshots.
     */
open func registerCloudModelsHandler(handler: CloudModelsHandler)  {try! rustCall() {
    uniffi_uzu_plus_fn_method_engine_register_cloud_models_handler(self.uniffiClonePointer(),
        FfiConverterCallbackInterfaceCloudModelsHandler_lower(handler),$0
    )
}
}
    
    /**
     * Register a Rust callback that will receive license status updates.
     */
open func registerLicenseStatusHandler(handler: LicenseStatusHandler)  {try! rustCall() {
    uniffi_uzu_plus_fn_method_engine_register_license_status_handler(self.uniffiClonePointer(),
        FfiConverterCallbackInterfaceLicenseStatusHandler_lower(handler),$0
    )
}
}
    
    /**
     * Register a callback that will receive model state updates.
     */
open func registerModelStateHandler(handler: ModelStateHandler)  {try! rustCall() {
    uniffi_uzu_plus_fn_method_engine_register_model_state_handler(self.uniffiClonePointer(),
        FfiConverterCallbackInterfaceModelStateHandler_lower(handler),$0
    )
}
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEngine: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Engine

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Engine {
        return Engine(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Engine) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Engine {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Engine, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEngine_lift(_ pointer: UnsafeMutableRawPointer) throws -> Engine {
    return try FfiConverterTypeEngine.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEngine_lower(_ value: Engine) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEngine.lower(value)
}






public protocol ModelDownloadHandleProtocol: AnyObject, Sendable {
    
    func delete() async throws 
    
    func download() async throws 
    
    func identifier()  -> String
    
    func pause() async throws 
    
    func progress()  -> ProgressStream
    
    func state() async throws  -> ModelDownloadState
    
}
open class ModelDownloadHandle: ModelDownloadHandleProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_uzu_plus_fn_clone_modeldownloadhandle(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_uzu_plus_fn_free_modeldownloadhandle(pointer, $0) }
    }

    

    
open func delete()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_uzu_plus_fn_method_modeldownloadhandle_delete(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_uzu_plus_rust_future_poll_void,
            completeFunc: ffi_uzu_plus_rust_future_complete_void,
            freeFunc: ffi_uzu_plus_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeModelStorageError_lift
        )
}
    
open func download()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_uzu_plus_fn_method_modeldownloadhandle_download(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_uzu_plus_rust_future_poll_void,
            completeFunc: ffi_uzu_plus_rust_future_complete_void,
            freeFunc: ffi_uzu_plus_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeModelStorageError_lift
        )
}
    
open func identifier() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_uzu_plus_fn_method_modeldownloadhandle_identifier(self.uniffiClonePointer(),$0
    )
})
}
    
open func pause()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_uzu_plus_fn_method_modeldownloadhandle_pause(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_uzu_plus_rust_future_poll_void,
            completeFunc: ffi_uzu_plus_rust_future_complete_void,
            freeFunc: ffi_uzu_plus_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeModelStorageError_lift
        )
}
    
open func progress() -> ProgressStream  {
    return try!  FfiConverterTypeProgressStream_lift(try! rustCall() {
    uniffi_uzu_plus_fn_method_modeldownloadhandle_progress(self.uniffiClonePointer(),$0
    )
})
}
    
open func state()async throws  -> ModelDownloadState  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_uzu_plus_fn_method_modeldownloadhandle_state(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_uzu_plus_rust_future_poll_rust_buffer,
            completeFunc: ffi_uzu_plus_rust_future_complete_rust_buffer,
            freeFunc: ffi_uzu_plus_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeModelDownloadState_lift,
            errorHandler: FfiConverterTypeModelStorageError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeModelDownloadHandle: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ModelDownloadHandle

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ModelDownloadHandle {
        return ModelDownloadHandle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ModelDownloadHandle) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ModelDownloadHandle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ModelDownloadHandle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeModelDownloadHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> ModelDownloadHandle {
    return try FfiConverterTypeModelDownloadHandle.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeModelDownloadHandle_lower(_ value: ModelDownloadHandle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeModelDownloadHandle.lower(value)
}






public protocol ProgressStreamProtocol: AnyObject, Sendable {
    
    func next() async  -> ProgressUpdate?
    
}
open class ProgressStream: ProgressStreamProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_uzu_plus_fn_clone_progressstream(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_uzu_plus_fn_free_progressstream(pointer, $0) }
    }

    

    
open func next()async  -> ProgressUpdate?  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_uzu_plus_fn_method_progressstream_next(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_uzu_plus_rust_future_poll_rust_buffer,
            completeFunc: ffi_uzu_plus_rust_future_complete_rust_buffer,
            freeFunc: ffi_uzu_plus_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeProgressUpdate.lift,
            errorHandler: nil
            
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProgressStream: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ProgressStream

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ProgressStream {
        return ProgressStream(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ProgressStream) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProgressStream {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ProgressStream, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProgressStream_lift(_ pointer: UnsafeMutableRawPointer) throws -> ProgressStream {
    return try FfiConverterTypeProgressStream.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProgressStream_lower(_ value: ProgressStream) -> UnsafeMutableRawPointer {
    return FfiConverterTypeProgressStream.lower(value)
}






public protocol SessionProtocol: AnyObject, Sendable {
    
    func run(input: Input, config: RunConfig, progress: ProgressHandler) throws  -> Output
    
}
open class Session: SessionProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_uzu_plus_fn_clone_session(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_uzu_plus_fn_free_session(pointer, $0) }
    }

    

    
open func run(input: Input, config: RunConfig, progress: ProgressHandler)throws  -> Output  {
    return try  FfiConverterTypeOutput_lift(try rustCallWithError(FfiConverterTypeError_lift) {
    uniffi_uzu_plus_fn_method_session_run(self.uniffiClonePointer(),
        FfiConverterTypeInput_lower(input),
        FfiConverterTypeRunConfig_lower(config),
        FfiConverterCallbackInterfaceProgressHandler_lower(progress),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSession: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Session

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Session {
        return Session(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Session) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Session {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Session, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSession_lift(_ pointer: UnsafeMutableRawPointer) throws -> Session {
    return try FfiConverterTypeSession.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSession_lower(_ value: Session) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSession.lower(value)
}




public struct ClassificationFeature {
    public var name: String
    public var values: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, values: [String]) {
        self.name = name
        self.values = values
    }
}

#if compiler(>=6)
extension ClassificationFeature: Sendable {}
#endif


extension ClassificationFeature: Equatable, Hashable {
    public static func ==(lhs: ClassificationFeature, rhs: ClassificationFeature) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.values != rhs.values {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(values)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClassificationFeature: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClassificationFeature {
        return
            try ClassificationFeature(
                name: FfiConverterString.read(from: &buf), 
                values: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: ClassificationFeature, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterSequenceString.write(value.values, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClassificationFeature_lift(_ buf: RustBuffer) throws -> ClassificationFeature {
    return try FfiConverterTypeClassificationFeature.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClassificationFeature_lower(_ value: ClassificationFeature) -> RustBuffer {
    return FfiConverterTypeClassificationFeature.lower(value)
}


public struct CloudModel {
    public var repoId: String
    public var name: String
    public var vendor: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(repoId: String, name: String, vendor: String) {
        self.repoId = repoId
        self.name = name
        self.vendor = vendor
    }
}

#if compiler(>=6)
extension CloudModel: Sendable {}
#endif


extension CloudModel: Equatable, Hashable {
    public static func ==(lhs: CloudModel, rhs: CloudModel) -> Bool {
        if lhs.repoId != rhs.repoId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.vendor != rhs.vendor {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(repoId)
        hasher.combine(name)
        hasher.combine(vendor)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCloudModel: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CloudModel {
        return
            try CloudModel(
                repoId: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                vendor: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: CloudModel, into buf: inout [UInt8]) {
        FfiConverterString.write(value.repoId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.vendor, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCloudModel_lift(_ buf: RustBuffer) throws -> CloudModel {
    return try FfiConverterTypeCloudModel.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCloudModel_lower(_ value: CloudModel) -> RustBuffer {
    return FfiConverterTypeCloudModel.lower(value)
}


public struct Config {
    public var preset: Preset
    public var prefillStepSize: PrefillStepSize
    public var contextLength: ContextLength
    public var samplingSeed: SamplingSeed

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(preset: Preset, prefillStepSize: PrefillStepSize, contextLength: ContextLength, samplingSeed: SamplingSeed) {
        self.preset = preset
        self.prefillStepSize = prefillStepSize
        self.contextLength = contextLength
        self.samplingSeed = samplingSeed
    }
}

#if compiler(>=6)
extension Config: Sendable {}
#endif


extension Config: Equatable, Hashable {
    public static func ==(lhs: Config, rhs: Config) -> Bool {
        if lhs.preset != rhs.preset {
            return false
        }
        if lhs.prefillStepSize != rhs.prefillStepSize {
            return false
        }
        if lhs.contextLength != rhs.contextLength {
            return false
        }
        if lhs.samplingSeed != rhs.samplingSeed {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(preset)
        hasher.combine(prefillStepSize)
        hasher.combine(contextLength)
        hasher.combine(samplingSeed)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Config {
        return
            try Config(
                preset: FfiConverterTypePreset.read(from: &buf), 
                prefillStepSize: FfiConverterTypePrefillStepSize.read(from: &buf), 
                contextLength: FfiConverterTypeContextLength.read(from: &buf), 
                samplingSeed: FfiConverterTypeSamplingSeed.read(from: &buf)
        )
    }

    public static func write(_ value: Config, into buf: inout [UInt8]) {
        FfiConverterTypePreset.write(value.preset, into: &buf)
        FfiConverterTypePrefillStepSize.write(value.prefillStepSize, into: &buf)
        FfiConverterTypeContextLength.write(value.contextLength, into: &buf)
        FfiConverterTypeSamplingSeed.write(value.samplingSeed, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfig_lift(_ buf: RustBuffer) throws -> Config {
    return try FfiConverterTypeConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfig_lower(_ value: Config) -> RustBuffer {
    return FfiConverterTypeConfig.lower(value)
}


public struct LocalModel {
    /**
     * Unique identifier of the model in the form `<vendor>-<name>-<precision>`.
     */
    public var identifier: String
    /**
     * Vendor/author of the model (e.g. "Alibaba", "Meta").
     */
    public var vendor: String
    /**
     * Human-readable model name without vendor (e.g. "Qwen2.5-0.5B-Instruct").
     */
    public var name: String
    /**
     * Precision of the model (e.g. "bfloat16", "float16").
     */
    public var precision: String
    /**
     * Quantization type if the model is quantized (e.g. "uint4").
     */
    public var quantization: String?
    /**
     * Optional regex to parse model output provided by the backend.
     */
    public var outputParserRegex: String?
    /**
     * Current download/installation state.
     */
    public var state: ModelDownloadState

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique identifier of the model in the form `<vendor>-<name>-<precision>`.
         */identifier: String, 
        /**
         * Vendor/author of the model (e.g. "Alibaba", "Meta").
         */vendor: String, 
        /**
         * Human-readable model name without vendor (e.g. "Qwen2.5-0.5B-Instruct").
         */name: String, 
        /**
         * Precision of the model (e.g. "bfloat16", "float16").
         */precision: String, 
        /**
         * Quantization type if the model is quantized (e.g. "uint4").
         */quantization: String?, 
        /**
         * Optional regex to parse model output provided by the backend.
         */outputParserRegex: String?, 
        /**
         * Current download/installation state.
         */state: ModelDownloadState) {
        self.identifier = identifier
        self.vendor = vendor
        self.name = name
        self.precision = precision
        self.quantization = quantization
        self.outputParserRegex = outputParserRegex
        self.state = state
    }
}

#if compiler(>=6)
extension LocalModel: Sendable {}
#endif


extension LocalModel: Equatable, Hashable {
    public static func ==(lhs: LocalModel, rhs: LocalModel) -> Bool {
        if lhs.identifier != rhs.identifier {
            return false
        }
        if lhs.vendor != rhs.vendor {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.precision != rhs.precision {
            return false
        }
        if lhs.quantization != rhs.quantization {
            return false
        }
        if lhs.outputParserRegex != rhs.outputParserRegex {
            return false
        }
        if lhs.state != rhs.state {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identifier)
        hasher.combine(vendor)
        hasher.combine(name)
        hasher.combine(precision)
        hasher.combine(quantization)
        hasher.combine(outputParserRegex)
        hasher.combine(state)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLocalModel: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocalModel {
        return
            try LocalModel(
                identifier: FfiConverterString.read(from: &buf), 
                vendor: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                precision: FfiConverterString.read(from: &buf), 
                quantization: FfiConverterOptionString.read(from: &buf), 
                outputParserRegex: FfiConverterOptionString.read(from: &buf), 
                state: FfiConverterTypeModelDownloadState.read(from: &buf)
        )
    }

    public static func write(_ value: LocalModel, into buf: inout [UInt8]) {
        FfiConverterString.write(value.identifier, into: &buf)
        FfiConverterString.write(value.vendor, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.precision, into: &buf)
        FfiConverterOptionString.write(value.quantization, into: &buf)
        FfiConverterOptionString.write(value.outputParserRegex, into: &buf)
        FfiConverterTypeModelDownloadState.write(value.state, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocalModel_lift(_ buf: RustBuffer) throws -> LocalModel {
    return try FfiConverterTypeLocalModel.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocalModel_lower(_ value: LocalModel) -> RustBuffer {
    return FfiConverterTypeLocalModel.lower(value)
}


public struct Message {
    public var role: Role
    public var content: String
    public var reasoningContent: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(role: Role, content: String, reasoningContent: String?) {
        self.role = role
        self.content = content
        self.reasoningContent = reasoningContent
    }
}

#if compiler(>=6)
extension Message: Sendable {}
#endif


extension Message: Equatable, Hashable {
    public static func ==(lhs: Message, rhs: Message) -> Bool {
        if lhs.role != rhs.role {
            return false
        }
        if lhs.content != rhs.content {
            return false
        }
        if lhs.reasoningContent != rhs.reasoningContent {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(role)
        hasher.combine(content)
        hasher.combine(reasoningContent)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Message {
        return
            try Message(
                role: FfiConverterTypeRole.read(from: &buf), 
                content: FfiConverterString.read(from: &buf), 
                reasoningContent: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Message, into buf: inout [UInt8]) {
        FfiConverterTypeRole.write(value.role, into: &buf)
        FfiConverterString.write(value.content, into: &buf)
        FfiConverterOptionString.write(value.reasoningContent, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessage_lift(_ buf: RustBuffer) throws -> Message {
    return try FfiConverterTypeMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessage_lower(_ value: Message) -> RustBuffer {
    return FfiConverterTypeMessage.lower(value)
}


public struct ModelDownloadState {
    /**
     * Total size of all model files in kilobytes.
     */
    public var totalKbytes: UInt32
    /**
     * Bytes already downloaded (meaningful in Downloading / Paused).
     */
    public var downloadedKbytes: UInt32
    /**
     * Current phase of the download.
     */
    public var phase: ModelDownloadPhase
    /**
     * Stringified error when `phase == ModelDownloadPhase::Error`.
     */
    public var error: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Total size of all model files in kilobytes.
         */totalKbytes: UInt32, 
        /**
         * Bytes already downloaded (meaningful in Downloading / Paused).
         */downloadedKbytes: UInt32, 
        /**
         * Current phase of the download.
         */phase: ModelDownloadPhase, 
        /**
         * Stringified error when `phase == ModelDownloadPhase::Error`.
         */error: String?) {
        self.totalKbytes = totalKbytes
        self.downloadedKbytes = downloadedKbytes
        self.phase = phase
        self.error = error
    }
}

#if compiler(>=6)
extension ModelDownloadState: Sendable {}
#endif


extension ModelDownloadState: Equatable, Hashable {
    public static func ==(lhs: ModelDownloadState, rhs: ModelDownloadState) -> Bool {
        if lhs.totalKbytes != rhs.totalKbytes {
            return false
        }
        if lhs.downloadedKbytes != rhs.downloadedKbytes {
            return false
        }
        if lhs.phase != rhs.phase {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(totalKbytes)
        hasher.combine(downloadedKbytes)
        hasher.combine(phase)
        hasher.combine(error)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeModelDownloadState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ModelDownloadState {
        return
            try ModelDownloadState(
                totalKbytes: FfiConverterUInt32.read(from: &buf), 
                downloadedKbytes: FfiConverterUInt32.read(from: &buf), 
                phase: FfiConverterTypeModelDownloadPhase.read(from: &buf), 
                error: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ModelDownloadState, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.totalKbytes, into: &buf)
        FfiConverterUInt32.write(value.downloadedKbytes, into: &buf)
        FfiConverterTypeModelDownloadPhase.write(value.phase, into: &buf)
        FfiConverterOptionString.write(value.error, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeModelDownloadState_lift(_ buf: RustBuffer) throws -> ModelDownloadState {
    return try FfiConverterTypeModelDownloadState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeModelDownloadState_lower(_ value: ModelDownloadState) -> RustBuffer {
    return FfiConverterTypeModelDownloadState.lower(value)
}


public struct Output {
    public var text: Text
    public var stats: Stats
    public var finishReason: FinishReason?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(text: Text, stats: Stats, finishReason: FinishReason?) {
        self.text = text
        self.stats = stats
        self.finishReason = finishReason
    }
}

#if compiler(>=6)
extension Output: Sendable {}
#endif


extension Output: Equatable, Hashable {
    public static func ==(lhs: Output, rhs: Output) -> Bool {
        if lhs.text != rhs.text {
            return false
        }
        if lhs.stats != rhs.stats {
            return false
        }
        if lhs.finishReason != rhs.finishReason {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(text)
        hasher.combine(stats)
        hasher.combine(finishReason)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOutput: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Output {
        return
            try Output(
                text: FfiConverterTypeText.read(from: &buf), 
                stats: FfiConverterTypeStats.read(from: &buf), 
                finishReason: FfiConverterOptionTypeFinishReason.read(from: &buf)
        )
    }

    public static func write(_ value: Output, into buf: inout [UInt8]) {
        FfiConverterTypeText.write(value.text, into: &buf)
        FfiConverterTypeStats.write(value.stats, into: &buf)
        FfiConverterOptionTypeFinishReason.write(value.finishReason, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOutput_lift(_ buf: RustBuffer) throws -> Output {
    return try FfiConverterTypeOutput.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOutput_lower(_ value: Output) -> RustBuffer {
    return FfiConverterTypeOutput.lower(value)
}


public struct ParsedText {
    public var chainOfThought: String?
    public var response: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(chainOfThought: String?, response: String?) {
        self.chainOfThought = chainOfThought
        self.response = response
    }
}

#if compiler(>=6)
extension ParsedText: Sendable {}
#endif


extension ParsedText: Equatable, Hashable {
    public static func ==(lhs: ParsedText, rhs: ParsedText) -> Bool {
        if lhs.chainOfThought != rhs.chainOfThought {
            return false
        }
        if lhs.response != rhs.response {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(chainOfThought)
        hasher.combine(response)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParsedText: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParsedText {
        return
            try ParsedText(
                chainOfThought: FfiConverterOptionString.read(from: &buf), 
                response: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ParsedText, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.chainOfThought, into: &buf)
        FfiConverterOptionString.write(value.response, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParsedText_lift(_ buf: RustBuffer) throws -> ParsedText {
    return try FfiConverterTypeParsedText.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParsedText_lower(_ value: ParsedText) -> RustBuffer {
    return FfiConverterTypeParsedText.lower(value)
}


public struct ProgressUpdate {
    /**
     * Bytes downloaded so far.
     */
    public var completedBytes: Double
    /**
     * Total bytes expected for the download; `None` while unknown.
     */
    public var totalBytes: Double?
    /**
     * Normalised progress between 0.0 and 1.0.
     */
    public var progress: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Bytes downloaded so far.
         */completedBytes: Double, 
        /**
         * Total bytes expected for the download; `None` while unknown.
         */totalBytes: Double?, 
        /**
         * Normalised progress between 0.0 and 1.0.
         */progress: Double) {
        self.completedBytes = completedBytes
        self.totalBytes = totalBytes
        self.progress = progress
    }
}

#if compiler(>=6)
extension ProgressUpdate: Sendable {}
#endif


extension ProgressUpdate: Equatable, Hashable {
    public static func ==(lhs: ProgressUpdate, rhs: ProgressUpdate) -> Bool {
        if lhs.completedBytes != rhs.completedBytes {
            return false
        }
        if lhs.totalBytes != rhs.totalBytes {
            return false
        }
        if lhs.progress != rhs.progress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(completedBytes)
        hasher.combine(totalBytes)
        hasher.combine(progress)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProgressUpdate: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProgressUpdate {
        return
            try ProgressUpdate(
                completedBytes: FfiConverterDouble.read(from: &buf), 
                totalBytes: FfiConverterOptionDouble.read(from: &buf), 
                progress: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: ProgressUpdate, into buf: inout [UInt8]) {
        FfiConverterDouble.write(value.completedBytes, into: &buf)
        FfiConverterOptionDouble.write(value.totalBytes, into: &buf)
        FfiConverterDouble.write(value.progress, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProgressUpdate_lift(_ buf: RustBuffer) throws -> ProgressUpdate {
    return try FfiConverterTypeProgressUpdate.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProgressUpdate_lower(_ value: ProgressUpdate) -> RustBuffer {
    return FfiConverterTypeProgressUpdate.lower(value)
}


public struct RunConfig {
    public var tokensLimit: Int64
    public var enableThinking: Bool
    public var samplingPolicy: SamplingPolicy

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(tokensLimit: Int64, enableThinking: Bool, samplingPolicy: SamplingPolicy) {
        self.tokensLimit = tokensLimit
        self.enableThinking = enableThinking
        self.samplingPolicy = samplingPolicy
    }
}

#if compiler(>=6)
extension RunConfig: Sendable {}
#endif


extension RunConfig: Equatable, Hashable {
    public static func ==(lhs: RunConfig, rhs: RunConfig) -> Bool {
        if lhs.tokensLimit != rhs.tokensLimit {
            return false
        }
        if lhs.enableThinking != rhs.enableThinking {
            return false
        }
        if lhs.samplingPolicy != rhs.samplingPolicy {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(tokensLimit)
        hasher.combine(enableThinking)
        hasher.combine(samplingPolicy)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRunConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RunConfig {
        return
            try RunConfig(
                tokensLimit: FfiConverterInt64.read(from: &buf), 
                enableThinking: FfiConverterBool.read(from: &buf), 
                samplingPolicy: FfiConverterTypeSamplingPolicy.read(from: &buf)
        )
    }

    public static func write(_ value: RunConfig, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.tokensLimit, into: &buf)
        FfiConverterBool.write(value.enableThinking, into: &buf)
        FfiConverterTypeSamplingPolicy.write(value.samplingPolicy, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRunConfig_lift(_ buf: RustBuffer) throws -> RunConfig {
    return try FfiConverterTypeRunConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRunConfig_lower(_ value: RunConfig) -> RustBuffer {
    return FfiConverterTypeRunConfig.lower(value)
}


public struct RunStats {
    public var count: UInt64
    public var averageDuration: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(count: UInt64, averageDuration: Double) {
        self.count = count
        self.averageDuration = averageDuration
    }
}

#if compiler(>=6)
extension RunStats: Sendable {}
#endif


extension RunStats: Equatable, Hashable {
    public static func ==(lhs: RunStats, rhs: RunStats) -> Bool {
        if lhs.count != rhs.count {
            return false
        }
        if lhs.averageDuration != rhs.averageDuration {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(count)
        hasher.combine(averageDuration)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRunStats: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RunStats {
        return
            try RunStats(
                count: FfiConverterUInt64.read(from: &buf), 
                averageDuration: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: RunStats, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.count, into: &buf)
        FfiConverterDouble.write(value.averageDuration, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRunStats_lift(_ buf: RustBuffer) throws -> RunStats {
    return try FfiConverterTypeRunStats.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRunStats_lower(_ value: RunStats) -> RustBuffer {
    return FfiConverterTypeRunStats.lower(value)
}


public struct Stats {
    public var prefillStats: StepStats
    public var generateStats: StepStats?
    public var totalStats: TotalStats

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(prefillStats: StepStats, generateStats: StepStats?, totalStats: TotalStats) {
        self.prefillStats = prefillStats
        self.generateStats = generateStats
        self.totalStats = totalStats
    }
}

#if compiler(>=6)
extension Stats: Sendable {}
#endif


extension Stats: Equatable, Hashable {
    public static func ==(lhs: Stats, rhs: Stats) -> Bool {
        if lhs.prefillStats != rhs.prefillStats {
            return false
        }
        if lhs.generateStats != rhs.generateStats {
            return false
        }
        if lhs.totalStats != rhs.totalStats {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(prefillStats)
        hasher.combine(generateStats)
        hasher.combine(totalStats)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStats: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Stats {
        return
            try Stats(
                prefillStats: FfiConverterTypeStepStats.read(from: &buf), 
                generateStats: FfiConverterOptionTypeStepStats.read(from: &buf), 
                totalStats: FfiConverterTypeTotalStats.read(from: &buf)
        )
    }

    public static func write(_ value: Stats, into buf: inout [UInt8]) {
        FfiConverterTypeStepStats.write(value.prefillStats, into: &buf)
        FfiConverterOptionTypeStepStats.write(value.generateStats, into: &buf)
        FfiConverterTypeTotalStats.write(value.totalStats, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStats_lift(_ buf: RustBuffer) throws -> Stats {
    return try FfiConverterTypeStats.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStats_lower(_ value: Stats) -> RustBuffer {
    return FfiConverterTypeStats.lower(value)
}


public struct StepStats {
    public var duration: Double
    public var suffixLength: UInt64
    public var tokensCount: UInt64
    public var tokensPerSecond: Double
    public var modelRun: RunStats
    public var run: RunStats?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(duration: Double, suffixLength: UInt64, tokensCount: UInt64, tokensPerSecond: Double, modelRun: RunStats, run: RunStats?) {
        self.duration = duration
        self.suffixLength = suffixLength
        self.tokensCount = tokensCount
        self.tokensPerSecond = tokensPerSecond
        self.modelRun = modelRun
        self.run = run
    }
}

#if compiler(>=6)
extension StepStats: Sendable {}
#endif


extension StepStats: Equatable, Hashable {
    public static func ==(lhs: StepStats, rhs: StepStats) -> Bool {
        if lhs.duration != rhs.duration {
            return false
        }
        if lhs.suffixLength != rhs.suffixLength {
            return false
        }
        if lhs.tokensCount != rhs.tokensCount {
            return false
        }
        if lhs.tokensPerSecond != rhs.tokensPerSecond {
            return false
        }
        if lhs.modelRun != rhs.modelRun {
            return false
        }
        if lhs.run != rhs.run {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(duration)
        hasher.combine(suffixLength)
        hasher.combine(tokensCount)
        hasher.combine(tokensPerSecond)
        hasher.combine(modelRun)
        hasher.combine(run)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStepStats: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StepStats {
        return
            try StepStats(
                duration: FfiConverterDouble.read(from: &buf), 
                suffixLength: FfiConverterUInt64.read(from: &buf), 
                tokensCount: FfiConverterUInt64.read(from: &buf), 
                tokensPerSecond: FfiConverterDouble.read(from: &buf), 
                modelRun: FfiConverterTypeRunStats.read(from: &buf), 
                run: FfiConverterOptionTypeRunStats.read(from: &buf)
        )
    }

    public static func write(_ value: StepStats, into buf: inout [UInt8]) {
        FfiConverterDouble.write(value.duration, into: &buf)
        FfiConverterUInt64.write(value.suffixLength, into: &buf)
        FfiConverterUInt64.write(value.tokensCount, into: &buf)
        FfiConverterDouble.write(value.tokensPerSecond, into: &buf)
        FfiConverterTypeRunStats.write(value.modelRun, into: &buf)
        FfiConverterOptionTypeRunStats.write(value.run, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStepStats_lift(_ buf: RustBuffer) throws -> StepStats {
    return try FfiConverterTypeStepStats.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStepStats_lower(_ value: StepStats) -> RustBuffer {
    return FfiConverterTypeStepStats.lower(value)
}


public struct Text {
    public var original: String
    public var parsed: ParsedText

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(original: String, parsed: ParsedText) {
        self.original = original
        self.parsed = parsed
    }
}

#if compiler(>=6)
extension Text: Sendable {}
#endif


extension Text: Equatable, Hashable {
    public static func ==(lhs: Text, rhs: Text) -> Bool {
        if lhs.original != rhs.original {
            return false
        }
        if lhs.parsed != rhs.parsed {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(original)
        hasher.combine(parsed)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeText: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Text {
        return
            try Text(
                original: FfiConverterString.read(from: &buf), 
                parsed: FfiConverterTypeParsedText.read(from: &buf)
        )
    }

    public static func write(_ value: Text, into buf: inout [UInt8]) {
        FfiConverterString.write(value.original, into: &buf)
        FfiConverterTypeParsedText.write(value.parsed, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeText_lift(_ buf: RustBuffer) throws -> Text {
    return try FfiConverterTypeText.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeText_lower(_ value: Text) -> RustBuffer {
    return FfiConverterTypeText.lower(value)
}


public struct TotalStats {
    public var duration: Double
    public var tokensCountInput: UInt64
    public var tokensCountOutput: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(duration: Double, tokensCountInput: UInt64, tokensCountOutput: UInt64) {
        self.duration = duration
        self.tokensCountInput = tokensCountInput
        self.tokensCountOutput = tokensCountOutput
    }
}

#if compiler(>=6)
extension TotalStats: Sendable {}
#endif


extension TotalStats: Equatable, Hashable {
    public static func ==(lhs: TotalStats, rhs: TotalStats) -> Bool {
        if lhs.duration != rhs.duration {
            return false
        }
        if lhs.tokensCountInput != rhs.tokensCountInput {
            return false
        }
        if lhs.tokensCountOutput != rhs.tokensCountOutput {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(duration)
        hasher.combine(tokensCountInput)
        hasher.combine(tokensCountOutput)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTotalStats: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TotalStats {
        return
            try TotalStats(
                duration: FfiConverterDouble.read(from: &buf), 
                tokensCountInput: FfiConverterUInt64.read(from: &buf), 
                tokensCountOutput: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: TotalStats, into buf: inout [UInt8]) {
        FfiConverterDouble.write(value.duration, into: &buf)
        FfiConverterUInt64.write(value.tokensCountInput, into: &buf)
        FfiConverterUInt64.write(value.tokensCountOutput, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTotalStats_lift(_ buf: RustBuffer) throws -> TotalStats {
    return try FfiConverterTypeTotalStats.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTotalStats_lower(_ value: TotalStats) -> RustBuffer {
    return FfiConverterTypeTotalStats.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ContextLength {
    
    case `default`
    case maximal
    case custom(length: Int64
    )
}


#if compiler(>=6)
extension ContextLength: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeContextLength: FfiConverterRustBuffer {
    typealias SwiftType = ContextLength

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContextLength {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`default`
        
        case 2: return .maximal
        
        case 3: return .custom(length: try FfiConverterInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ContextLength, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`default`:
            writeInt(&buf, Int32(1))
        
        
        case .maximal:
            writeInt(&buf, Int32(2))
        
        
        case let .custom(length):
            writeInt(&buf, Int32(3))
            FfiConverterInt64.write(length, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContextLength_lift(_ buf: RustBuffer) throws -> ContextLength {
    return try FfiConverterTypeContextLength.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContextLength_lower(_ value: ContextLength) -> RustBuffer {
    return FfiConverterTypeContextLength.lower(value)
}


extension ContextLength: Equatable, Hashable {}




public enum EngineError: Swift.Error {

    
    
    case General(message: String
    )
    case Storage(StorageError
    )
    case ModelStorage(ModelStorageError
    )
    case Session(Error
    )
    case Network(NetworkError
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEngineError: FfiConverterRustBuffer {
    typealias SwiftType = EngineError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EngineError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .General(
            message: try FfiConverterString.read(from: &buf)
            )
        case 2: return .Storage(
            try FfiConverterTypeStorageError.read(from: &buf)
            )
        case 3: return .ModelStorage(
            try FfiConverterTypeModelStorageError.read(from: &buf)
            )
        case 4: return .Session(
            try FfiConverterTypeError.read(from: &buf)
            )
        case 5: return .Network(
            try FfiConverterTypeNetworkError.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EngineError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .General(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .Storage(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeStorageError.write(v1, into: &buf)
            
        
        case let .ModelStorage(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeModelStorageError.write(v1, into: &buf)
            
        
        case let .Session(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeError.write(v1, into: &buf)
            
        
        case let .Network(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeNetworkError.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEngineError_lift(_ buf: RustBuffer) throws -> EngineError {
    return try FfiConverterTypeEngineError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEngineError_lower(_ value: EngineError) -> RustBuffer {
    return FfiConverterTypeEngineError.lower(value)
}


extension EngineError: Equatable, Hashable {}





public enum Error: Swift.Error {

    
    
    case ModelFolderNotFound
    case UnableToCreateMetalContext
    case UnableToLoadConfig
    case UnableToLoadWeights
    case UnableToLoadTokenizer
    case NotEnoughMemory
    case GeneratorNotLoaded
    case UnableToLoadPromptTemplate
    case UnableToRenderPromptTemplate
    case UnexpectedReasoningContent
    case UnableToBuildOutputParserRegex
    case UnableToEncodeText
    case UnableToDecodeText
    case ContextLengthExceeded
    case PrefillFailed
    case GenerateFailed
    case SamplingFailed
    case UnexpectedCallSequence
    case UnsupportedPreset
    case ResponseParseError
    case NetworkError(message: String
    )
    case HttpError(code: UInt16, message: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeError: FfiConverterRustBuffer {
    typealias SwiftType = Error

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Error {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ModelFolderNotFound
        case 2: return .UnableToCreateMetalContext
        case 3: return .UnableToLoadConfig
        case 4: return .UnableToLoadWeights
        case 5: return .UnableToLoadTokenizer
        case 6: return .NotEnoughMemory
        case 7: return .GeneratorNotLoaded
        case 8: return .UnableToLoadPromptTemplate
        case 9: return .UnableToRenderPromptTemplate
        case 10: return .UnexpectedReasoningContent
        case 11: return .UnableToBuildOutputParserRegex
        case 12: return .UnableToEncodeText
        case 13: return .UnableToDecodeText
        case 14: return .ContextLengthExceeded
        case 15: return .PrefillFailed
        case 16: return .GenerateFailed
        case 17: return .SamplingFailed
        case 18: return .UnexpectedCallSequence
        case 19: return .UnsupportedPreset
        case 20: return .ResponseParseError
        case 21: return .NetworkError(
            message: try FfiConverterString.read(from: &buf)
            )
        case 22: return .HttpError(
            code: try FfiConverterUInt16.read(from: &buf), 
            message: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Error, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .ModelFolderNotFound:
            writeInt(&buf, Int32(1))
        
        
        case .UnableToCreateMetalContext:
            writeInt(&buf, Int32(2))
        
        
        case .UnableToLoadConfig:
            writeInt(&buf, Int32(3))
        
        
        case .UnableToLoadWeights:
            writeInt(&buf, Int32(4))
        
        
        case .UnableToLoadTokenizer:
            writeInt(&buf, Int32(5))
        
        
        case .NotEnoughMemory:
            writeInt(&buf, Int32(6))
        
        
        case .GeneratorNotLoaded:
            writeInt(&buf, Int32(7))
        
        
        case .UnableToLoadPromptTemplate:
            writeInt(&buf, Int32(8))
        
        
        case .UnableToRenderPromptTemplate:
            writeInt(&buf, Int32(9))
        
        
        case .UnexpectedReasoningContent:
            writeInt(&buf, Int32(10))
        
        
        case .UnableToBuildOutputParserRegex:
            writeInt(&buf, Int32(11))
        
        
        case .UnableToEncodeText:
            writeInt(&buf, Int32(12))
        
        
        case .UnableToDecodeText:
            writeInt(&buf, Int32(13))
        
        
        case .ContextLengthExceeded:
            writeInt(&buf, Int32(14))
        
        
        case .PrefillFailed:
            writeInt(&buf, Int32(15))
        
        
        case .GenerateFailed:
            writeInt(&buf, Int32(16))
        
        
        case .SamplingFailed:
            writeInt(&buf, Int32(17))
        
        
        case .UnexpectedCallSequence:
            writeInt(&buf, Int32(18))
        
        
        case .UnsupportedPreset:
            writeInt(&buf, Int32(19))
        
        
        case .ResponseParseError:
            writeInt(&buf, Int32(20))
        
        
        case let .NetworkError(message):
            writeInt(&buf, Int32(21))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .HttpError(code,message):
            writeInt(&buf, Int32(22))
            FfiConverterUInt16.write(code, into: &buf)
            FfiConverterString.write(message, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeError_lift(_ buf: RustBuffer) throws -> Error {
    return try FfiConverterTypeError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeError_lower(_ value: Error) -> RustBuffer {
    return FfiConverterTypeError.lower(value)
}


extension Error: Equatable, Hashable {}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FinishReason {
    
    case stop
    case length
    case cancelled
    case contextLimitReached
}


#if compiler(>=6)
extension FinishReason: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFinishReason: FfiConverterRustBuffer {
    typealias SwiftType = FinishReason

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FinishReason {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .stop
        
        case 2: return .length
        
        case 3: return .cancelled
        
        case 4: return .contextLimitReached
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FinishReason, into buf: inout [UInt8]) {
        switch value {
        
        
        case .stop:
            writeInt(&buf, Int32(1))
        
        
        case .length:
            writeInt(&buf, Int32(2))
        
        
        case .cancelled:
            writeInt(&buf, Int32(3))
        
        
        case .contextLimitReached:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFinishReason_lift(_ buf: RustBuffer) throws -> FinishReason {
    return try FfiConverterTypeFinishReason.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFinishReason_lower(_ value: FinishReason) -> RustBuffer {
    return FfiConverterTypeFinishReason.lower(value)
}


extension FinishReason: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Input {
    
    case text(text: String
    )
    case messages(messages: [Message]
    )
}


#if compiler(>=6)
extension Input: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInput: FfiConverterRustBuffer {
    typealias SwiftType = Input

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Input {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .text(text: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .messages(messages: try FfiConverterSequenceTypeMessage.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Input, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .text(text):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(text, into: &buf)
            
        
        case let .messages(messages):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeMessage.write(messages, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInput_lift(_ buf: RustBuffer) throws -> Input {
    return try FfiConverterTypeInput.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInput_lower(_ value: Input) -> RustBuffer {
    return FfiConverterTypeInput.lower(value)
}


extension Input: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LicenseStatus {
    
    case notActivated
    case paymentRequired
    case gracePeriodActive
    case activated
    case networkError
    case invalidApiKey
    case signatureMismatch
    /**
     * The HTTP request timed out before receiving a response.
     */
    case timeout
    /**
     * The server responded with a non-success HTTP status code (e.g. 404, 429, 500 …).
     */
    case httpError(code: UInt16
    )
}


#if compiler(>=6)
extension LicenseStatus: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLicenseStatus: FfiConverterRustBuffer {
    typealias SwiftType = LicenseStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LicenseStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .notActivated
        
        case 2: return .paymentRequired
        
        case 3: return .gracePeriodActive
        
        case 4: return .activated
        
        case 5: return .networkError
        
        case 6: return .invalidApiKey
        
        case 7: return .signatureMismatch
        
        case 8: return .timeout
        
        case 9: return .httpError(code: try FfiConverterUInt16.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LicenseStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .notActivated:
            writeInt(&buf, Int32(1))
        
        
        case .paymentRequired:
            writeInt(&buf, Int32(2))
        
        
        case .gracePeriodActive:
            writeInt(&buf, Int32(3))
        
        
        case .activated:
            writeInt(&buf, Int32(4))
        
        
        case .networkError:
            writeInt(&buf, Int32(5))
        
        
        case .invalidApiKey:
            writeInt(&buf, Int32(6))
        
        
        case .signatureMismatch:
            writeInt(&buf, Int32(7))
        
        
        case .timeout:
            writeInt(&buf, Int32(8))
        
        
        case let .httpError(code):
            writeInt(&buf, Int32(9))
            FfiConverterUInt16.write(code, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLicenseStatus_lift(_ buf: RustBuffer) throws -> LicenseStatus {
    return try FfiConverterTypeLicenseStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLicenseStatus_lower(_ value: LicenseStatus) -> RustBuffer {
    return FfiConverterTypeLicenseStatus.lower(value)
}


extension LicenseStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ModelDownloadPhase {
    
    case notDownloaded
    case downloading
    case paused
    case downloaded
    case error
}


#if compiler(>=6)
extension ModelDownloadPhase: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeModelDownloadPhase: FfiConverterRustBuffer {
    typealias SwiftType = ModelDownloadPhase

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ModelDownloadPhase {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .notDownloaded
        
        case 2: return .downloading
        
        case 3: return .paused
        
        case 4: return .downloaded
        
        case 5: return .error
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ModelDownloadPhase, into buf: inout [UInt8]) {
        switch value {
        
        
        case .notDownloaded:
            writeInt(&buf, Int32(1))
        
        
        case .downloading:
            writeInt(&buf, Int32(2))
        
        
        case .paused:
            writeInt(&buf, Int32(3))
        
        
        case .downloaded:
            writeInt(&buf, Int32(4))
        
        
        case .error:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeModelDownloadPhase_lift(_ buf: RustBuffer) throws -> ModelDownloadPhase {
    return try FfiConverterTypeModelDownloadPhase.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeModelDownloadPhase_lower(_ value: ModelDownloadPhase) -> RustBuffer {
    return FfiConverterTypeModelDownloadPhase.lower(value)
}


extension ModelDownloadPhase: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ModelId {
    
    case local(id: String
    )
    case cloud(id: String
    )
}


#if compiler(>=6)
extension ModelId: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeModelID: FfiConverterRustBuffer {
    typealias SwiftType = ModelId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ModelId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .local(id: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .cloud(id: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ModelId, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .local(id):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(id, into: &buf)
            
        
        case let .cloud(id):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(id, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeModelID_lift(_ buf: RustBuffer) throws -> ModelId {
    return try FfiConverterTypeModelID.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeModelID_lower(_ value: ModelId) -> RustBuffer {
    return FfiConverterTypeModelID.lower(value)
}


extension ModelId: Equatable, Hashable {}




public enum ModelStorageError: Swift.Error {

    
    
    case Io(message: String
    )
    case Network(message: String
    )
    case DownloadFailed(message: String
    )
    case Download(message: String
    )
    case InvalidPath(message: String
    )
    case ModelNotFound(identifier: String
    )
    case FileVerificationFailed(message: String
    )
    case Paused
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeModelStorageError: FfiConverterRustBuffer {
    typealias SwiftType = ModelStorageError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ModelStorageError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Io(
            message: try FfiConverterString.read(from: &buf)
            )
        case 2: return .Network(
            message: try FfiConverterString.read(from: &buf)
            )
        case 3: return .DownloadFailed(
            message: try FfiConverterString.read(from: &buf)
            )
        case 4: return .Download(
            message: try FfiConverterString.read(from: &buf)
            )
        case 5: return .InvalidPath(
            message: try FfiConverterString.read(from: &buf)
            )
        case 6: return .ModelNotFound(
            identifier: try FfiConverterString.read(from: &buf)
            )
        case 7: return .FileVerificationFailed(
            message: try FfiConverterString.read(from: &buf)
            )
        case 8: return .Paused

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ModelStorageError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Io(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .Network(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .DownloadFailed(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .Download(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .InvalidPath(message):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .ModelNotFound(identifier):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(identifier, into: &buf)
            
        
        case let .FileVerificationFailed(message):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(message, into: &buf)
            
        
        case .Paused:
            writeInt(&buf, Int32(8))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeModelStorageError_lift(_ buf: RustBuffer) throws -> ModelStorageError {
    return try FfiConverterTypeModelStorageError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeModelStorageError_lower(_ value: ModelStorageError) -> RustBuffer {
    return FfiConverterTypeModelStorageError.lower(value)
}


extension ModelStorageError: Equatable, Hashable {}





public enum NetworkError: Swift.Error {

    
    
    case Request(message: String
    )
    case HttpStatus(status: UInt16
    )
    case Parse(message: String
    )
    case Join(message: String
    )
    case Timeout
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNetworkError: FfiConverterRustBuffer {
    typealias SwiftType = NetworkError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Request(
            message: try FfiConverterString.read(from: &buf)
            )
        case 2: return .HttpStatus(
            status: try FfiConverterUInt16.read(from: &buf)
            )
        case 3: return .Parse(
            message: try FfiConverterString.read(from: &buf)
            )
        case 4: return .Join(
            message: try FfiConverterString.read(from: &buf)
            )
        case 5: return .Timeout

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NetworkError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Request(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .HttpStatus(status):
            writeInt(&buf, Int32(2))
            FfiConverterUInt16.write(status, into: &buf)
            
        
        case let .Parse(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .Join(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
            
        
        case .Timeout:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetworkError_lift(_ buf: RustBuffer) throws -> NetworkError {
    return try FfiConverterTypeNetworkError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetworkError_lower(_ value: NetworkError) -> RustBuffer {
    return FfiConverterTypeNetworkError.lower(value)
}


extension NetworkError: Equatable, Hashable {}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PrefillStepSize {
    
    case `default`
    case maximal
    case custom(length: Int64
    )
}


#if compiler(>=6)
extension PrefillStepSize: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePrefillStepSize: FfiConverterRustBuffer {
    typealias SwiftType = PrefillStepSize

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrefillStepSize {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`default`
        
        case 2: return .maximal
        
        case 3: return .custom(length: try FfiConverterInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PrefillStepSize, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`default`:
            writeInt(&buf, Int32(1))
        
        
        case .maximal:
            writeInt(&buf, Int32(2))
        
        
        case let .custom(length):
            writeInt(&buf, Int32(3))
            FfiConverterInt64.write(length, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrefillStepSize_lift(_ buf: RustBuffer) throws -> PrefillStepSize {
    return try FfiConverterTypePrefillStepSize.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrefillStepSize_lower(_ value: PrefillStepSize) -> RustBuffer {
    return FfiConverterTypePrefillStepSize.lower(value)
}


extension PrefillStepSize: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Preset {
    
    case general
    case classification(feature: ClassificationFeature
    )
    case summarization
}


#if compiler(>=6)
extension Preset: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePreset: FfiConverterRustBuffer {
    typealias SwiftType = Preset

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Preset {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .general
        
        case 2: return .classification(feature: try FfiConverterTypeClassificationFeature.read(from: &buf)
        )
        
        case 3: return .summarization
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Preset, into buf: inout [UInt8]) {
        switch value {
        
        
        case .general:
            writeInt(&buf, Int32(1))
        
        
        case let .classification(feature):
            writeInt(&buf, Int32(2))
            FfiConverterTypeClassificationFeature.write(feature, into: &buf)
            
        
        case .summarization:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePreset_lift(_ buf: RustBuffer) throws -> Preset {
    return try FfiConverterTypePreset.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePreset_lower(_ value: Preset) -> RustBuffer {
    return FfiConverterTypePreset.lower(value)
}


extension Preset: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Role {
    
    case system
    case user
    case assistant
}


#if compiler(>=6)
extension Role: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRole: FfiConverterRustBuffer {
    typealias SwiftType = Role

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Role {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .system
        
        case 2: return .user
        
        case 3: return .assistant
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Role, into buf: inout [UInt8]) {
        switch value {
        
        
        case .system:
            writeInt(&buf, Int32(1))
        
        
        case .user:
            writeInt(&buf, Int32(2))
        
        
        case .assistant:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRole_lift(_ buf: RustBuffer) throws -> Role {
    return try FfiConverterTypeRole.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRole_lower(_ value: Role) -> RustBuffer {
    return FfiConverterTypeRole.lower(value)
}


extension Role: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SamplingMethod {
    
    case greedy
    case temperature(temperature: Double
    )
    case topP(topP: Double
    )
}


#if compiler(>=6)
extension SamplingMethod: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSamplingMethod: FfiConverterRustBuffer {
    typealias SwiftType = SamplingMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SamplingMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .greedy
        
        case 2: return .temperature(temperature: try FfiConverterDouble.read(from: &buf)
        )
        
        case 3: return .topP(topP: try FfiConverterDouble.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SamplingMethod, into buf: inout [UInt8]) {
        switch value {
        
        
        case .greedy:
            writeInt(&buf, Int32(1))
        
        
        case let .temperature(temperature):
            writeInt(&buf, Int32(2))
            FfiConverterDouble.write(temperature, into: &buf)
            
        
        case let .topP(topP):
            writeInt(&buf, Int32(3))
            FfiConverterDouble.write(topP, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSamplingMethod_lift(_ buf: RustBuffer) throws -> SamplingMethod {
    return try FfiConverterTypeSamplingMethod.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSamplingMethod_lower(_ value: SamplingMethod) -> RustBuffer {
    return FfiConverterTypeSamplingMethod.lower(value)
}


extension SamplingMethod: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SamplingPolicy {
    
    case `default`
    case custom(value: SamplingMethod
    )
}


#if compiler(>=6)
extension SamplingPolicy: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSamplingPolicy: FfiConverterRustBuffer {
    typealias SwiftType = SamplingPolicy

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SamplingPolicy {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`default`
        
        case 2: return .custom(value: try FfiConverterTypeSamplingMethod.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SamplingPolicy, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`default`:
            writeInt(&buf, Int32(1))
        
        
        case let .custom(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSamplingMethod.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSamplingPolicy_lift(_ buf: RustBuffer) throws -> SamplingPolicy {
    return try FfiConverterTypeSamplingPolicy.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSamplingPolicy_lower(_ value: SamplingPolicy) -> RustBuffer {
    return FfiConverterTypeSamplingPolicy.lower(value)
}


extension SamplingPolicy: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SamplingSeed {
    
    case `default`
    case custom(seed: Int64
    )
}


#if compiler(>=6)
extension SamplingSeed: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSamplingSeed: FfiConverterRustBuffer {
    typealias SwiftType = SamplingSeed

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SamplingSeed {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`default`
        
        case 2: return .custom(seed: try FfiConverterInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SamplingSeed, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`default`:
            writeInt(&buf, Int32(1))
        
        
        case let .custom(seed):
            writeInt(&buf, Int32(2))
            FfiConverterInt64.write(seed, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSamplingSeed_lift(_ buf: RustBuffer) throws -> SamplingSeed {
    return try FfiConverterTypeSamplingSeed.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSamplingSeed_lower(_ value: SamplingSeed) -> RustBuffer {
    return FfiConverterTypeSamplingSeed.lower(value)
}


extension SamplingSeed: Equatable, Hashable {}




public enum StorageError: Swift.Error {

    
    
    case ModelNotDownloaded
    case UnknownModel(identifier: String
    )
    case Storage(message: String
    )
    case MutexPoisoned(message: String
    )
    case LicenseNotActivated
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStorageError: FfiConverterRustBuffer {
    typealias SwiftType = StorageError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StorageError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ModelNotDownloaded
        case 2: return .UnknownModel(
            identifier: try FfiConverterString.read(from: &buf)
            )
        case 3: return .Storage(
            message: try FfiConverterString.read(from: &buf)
            )
        case 4: return .MutexPoisoned(
            message: try FfiConverterString.read(from: &buf)
            )
        case 5: return .LicenseNotActivated

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: StorageError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .ModelNotDownloaded:
            writeInt(&buf, Int32(1))
        
        
        case let .UnknownModel(identifier):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(identifier, into: &buf)
            
        
        case let .Storage(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .MutexPoisoned(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
            
        
        case .LicenseNotActivated:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStorageError_lift(_ buf: RustBuffer) throws -> StorageError {
    return try FfiConverterTypeStorageError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStorageError_lower(_ value: StorageError) -> RustBuffer {
    return FfiConverterTypeStorageError.lower(value)
}


extension StorageError: Equatable, Hashable {}







/**
 * Callback interface to push cloud models snapshots to the host.
 */
public protocol CloudModelsHandler: AnyObject, Sendable {
    
    func onCloudModels(models: [CloudModel]) 
    
}
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceCloudModelsHandler {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceCloudModelsHandler] = [UniffiVTableCallbackInterfaceCloudModelsHandler(
        onCloudModels: { (
            uniffiHandle: UInt64,
            models: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceCloudModelsHandler.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onCloudModels(
                     models: try FfiConverterSequenceTypeCloudModel.lift(models)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceCloudModelsHandler.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface CloudModelsHandler: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitCloudModelsHandler() {
    uniffi_uzu_plus_fn_init_callback_vtable_cloudmodelshandler(UniffiCallbackInterfaceCloudModelsHandler.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceCloudModelsHandler {
    fileprivate static let handleMap = UniffiHandleMap<CloudModelsHandler>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceCloudModelsHandler : FfiConverter {
    typealias SwiftType = CloudModelsHandler
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceCloudModelsHandler_lift(_ handle: UInt64) throws -> CloudModelsHandler {
    return try FfiConverterCallbackInterfaceCloudModelsHandler.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceCloudModelsHandler_lower(_ v: CloudModelsHandler) -> UInt64 {
    return FfiConverterCallbackInterfaceCloudModelsHandler.lower(v)
}




/**
 * Callback interface Swift implements to react to license status changes.
 */
public protocol LicenseStatusHandler: AnyObject, Sendable {
    
    func onStatus(status: LicenseStatus) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceLicenseStatusHandler {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceLicenseStatusHandler] = [UniffiVTableCallbackInterfaceLicenseStatusHandler(
        onStatus: { (
            uniffiHandle: UInt64,
            status: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceLicenseStatusHandler.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onStatus(
                     status: try FfiConverterTypeLicenseStatus_lift(status)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceLicenseStatusHandler.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface LicenseStatusHandler: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitLicenseStatusHandler() {
    uniffi_uzu_plus_fn_init_callback_vtable_licensestatushandler(UniffiCallbackInterfaceLicenseStatusHandler.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceLicenseStatusHandler {
    fileprivate static let handleMap = UniffiHandleMap<LicenseStatusHandler>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceLicenseStatusHandler : FfiConverter {
    typealias SwiftType = LicenseStatusHandler
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceLicenseStatusHandler_lift(_ handle: UInt64) throws -> LicenseStatusHandler {
    return try FfiConverterCallbackInterfaceLicenseStatusHandler.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceLicenseStatusHandler_lower(_ v: LicenseStatusHandler) -> UInt64 {
    return FfiConverterCallbackInterfaceLicenseStatusHandler.lower(v)
}




/**
 * Callback interface Swift implements to react to state changes.
 */
public protocol ModelStateHandler: AnyObject, Sendable {
    
    func onLocalModel(model: LocalModel) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceModelStateHandler {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceModelStateHandler] = [UniffiVTableCallbackInterfaceModelStateHandler(
        onLocalModel: { (
            uniffiHandle: UInt64,
            model: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceModelStateHandler.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onLocalModel(
                     model: try FfiConverterTypeLocalModel_lift(model)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceModelStateHandler.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface ModelStateHandler: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitModelStateHandler() {
    uniffi_uzu_plus_fn_init_callback_vtable_modelstatehandler(UniffiCallbackInterfaceModelStateHandler.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceModelStateHandler {
    fileprivate static let handleMap = UniffiHandleMap<ModelStateHandler>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceModelStateHandler : FfiConverter {
    typealias SwiftType = ModelStateHandler
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceModelStateHandler_lift(_ handle: UInt64) throws -> ModelStateHandler {
    return try FfiConverterCallbackInterfaceModelStateHandler.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceModelStateHandler_lower(_ v: ModelStateHandler) -> UInt64 {
    return FfiConverterCallbackInterfaceModelStateHandler.lower(v)
}




public protocol ProgressHandler: AnyObject, Sendable {
    
    func onProgress(output: Output)  -> Bool
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceProgressHandler {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceProgressHandler] = [UniffiVTableCallbackInterfaceProgressHandler(
        onProgress: { (
            uniffiHandle: UInt64,
            output: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<Int8>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Bool in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceProgressHandler.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onProgress(
                     output: try FfiConverterTypeOutput_lift(output)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterBool.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceProgressHandler.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface ProgressHandler: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitProgressHandler() {
    uniffi_uzu_plus_fn_init_callback_vtable_progresshandler(UniffiCallbackInterfaceProgressHandler.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceProgressHandler {
    fileprivate static let handleMap = UniffiHandleMap<ProgressHandler>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceProgressHandler : FfiConverter {
    typealias SwiftType = ProgressHandler
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceProgressHandler_lift(_ handle: UInt64) throws -> ProgressHandler {
    return try FfiConverterCallbackInterfaceProgressHandler.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceProgressHandler_lower(_ v: ProgressHandler) -> UInt64 {
    return FfiConverterCallbackInterfaceProgressHandler.lower(v)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionDouble: FfiConverterRustBuffer {
    typealias SwiftType = Double?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDouble.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDouble.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeProgressUpdate: FfiConverterRustBuffer {
    typealias SwiftType = ProgressUpdate?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeProgressUpdate.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeProgressUpdate.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeRunStats: FfiConverterRustBuffer {
    typealias SwiftType = RunStats?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRunStats.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRunStats.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeStepStats: FfiConverterRustBuffer {
    typealias SwiftType = StepStats?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeStepStats.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeStepStats.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFinishReason: FfiConverterRustBuffer {
    typealias SwiftType = FinishReason?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFinishReason.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFinishReason.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeCloudModel: FfiConverterRustBuffer {
    typealias SwiftType = [CloudModel]

    public static func write(_ value: [CloudModel], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCloudModel.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [CloudModel] {
        let len: Int32 = try readInt(&buf)
        var seq = [CloudModel]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCloudModel.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeLocalModel: FfiConverterRustBuffer {
    typealias SwiftType = [LocalModel]

    public static func write(_ value: [LocalModel], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLocalModel.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LocalModel] {
        let len: Int32 = try readInt(&buf)
        var seq = [LocalModel]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLocalModel.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeMessage: FfiConverterRustBuffer {
    typealias SwiftType = [Message]

    public static func write(_ value: [Message], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMessage.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Message] {
        let len: Int32 = try readInt(&buf)
        var seq = [Message]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMessage.read(from: &buf))
        }
        return seq
    }
}
private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call the ensure init function since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureUzuPlusInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
public func errorUserDescription(err: EngineError) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_uzu_plus_fn_func_error_user_description(
        FfiConverterTypeEngineError_lower(err),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_uzu_plus_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_uzu_plus_checksum_func_error_user_description() != 33340) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_engine_activate() != 42274) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_engine_createsession() != 14385) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_engine_delete_model() != 61100) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_engine_download_handle() != 15221) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_engine_download_model() != 16804) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_engine_fetch_cloud_models() != 34214) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_engine_get_cloud_models() != 24823) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_engine_get_local_models() != 11177) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_engine_get_state() != 21567) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_engine_pause_model() != 42664) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_engine_register_cloud_models_handler() != 7831) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_engine_register_license_status_handler() != 12399) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_engine_register_model_state_handler() != 6455) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_modeldownloadhandle_delete() != 1956) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_modeldownloadhandle_download() != 10145) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_modeldownloadhandle_identifier() != 45185) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_modeldownloadhandle_pause() != 65533) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_modeldownloadhandle_progress() != 48508) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_modeldownloadhandle_state() != 64352) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_progressstream_next() != 52954) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_session_run() != 25066) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_constructor_engine_make() != 13877) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_cloudmodelshandler_on_cloud_models() != 52474) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_licensestatushandler_on_status() != 36495) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_modelstatehandler_on_local_model() != 56178) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uzu_plus_checksum_method_progresshandler_on_progress() != 19494) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitCloudModelsHandler()
    uniffiCallbackInitLicenseStatusHandler()
    uniffiCallbackInitModelStateHandler()
    uniffiCallbackInitProgressHandler()
    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureUzuPlusInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all